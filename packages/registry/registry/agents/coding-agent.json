{
	"name": "coding-agent",
	"type": "registry:agent",
	"title": "Coding Agent",
	"description": "Coding Agent - an AI agent",
	"dependencies": [
		"ai"
	],
	"registryDependencies": [
		"agents:lib/permissions",
		"prompts:coding-agent",
		"tools:bash",
		"tools:edit",
		"tools:glob",
		"tools:grep",
		"tools:list",
		"tools:read",
		"tools:write"
	],
	"files": [
		{
			"path": "agents/coding-agent.ts",
			"type": "registry:agent",
			"content": "import { Experimental_Agent as Agent, type LanguageModel } from \"ai\"\nimport { type ToolPermissions } from \"@/agents/lib/permissions\"\nimport { getSystemPrompt } from \"@/prompts/coding-agent\"\nimport { createBashTool } from \"@/tools/bash\"\nimport { createEditTool } from \"@/tools/edit\"\nimport { globTool } from \"@/tools/glob\"\nimport { grepTool } from \"@/tools/grep\"\nimport { listTool } from \"@/tools/list\"\nimport { readTool } from \"@/tools/read\"\nimport { createWriteTool } from \"@/tools/write\"\n\nexport interface AgentSettings {\n\tmodel: LanguageModel\n\tworkingDirectory?: string\n\tplatform?: string\n\tdate?: string\n\tdebug?: boolean\n\t/** Custom permission patterns for tools. */\n\tpermissions?: ToolPermissions\n}\n\nexport function createAgent({\n\tmodel,\n\tworkingDirectory,\n\tplatform,\n\tdate,\n\tdebug,\n\tpermissions,\n}: AgentSettings) {\n\tconst instructions = getSystemPrompt({\n\t\tworkingDirectory,\n\t\tplatform,\n\t\tdate,\n\t})\n\n\tconst tools = {\n\t\tread: readTool,\n\t\twrite: createWriteTool(permissions?.write),\n\t\tedit: createEditTool(permissions?.edit),\n\t\tbash: createBashTool(permissions?.bash),\n\t\tlist: listTool,\n\t\tgrep: grepTool,\n\t\tglob: globTool,\n\t}\n\n\tconst agent = new Agent({\n\t\tmodel,\n\t\tinstructions,\n\t\ttools,\n\t\tproviderOptions: {\n\t\t\topenai: {\n\t\t\t\treasoningEffort: \"medium\",\n\t\t\t\treasoningSummary: \"detailed\",\n\t\t\t},\n\t\t},\n\t\tstopWhen: ({ steps }) => {\n\t\t\tif (steps.length === 0) return false\n\n\t\t\tconst lastStep = steps[steps.length - 1]\n\t\t\tif (!lastStep) return false\n\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(`\\nğŸ“Š [Debug] Step ${steps.length} completed`)\n\t\t\t\tif (lastStep.toolCalls && lastStep.toolCalls.length > 0) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`   Tool calls: ${lastStep.toolCalls.map((tc) => tc.toolName).join(\", \")}`,\n\t\t\t\t\t)\n\t\t\t\t\t// Log tool results if available\n\t\t\t\t\tif (lastStep.toolResults) {\n\t\t\t\t\t\tfor (const result of lastStep.toolResults) {\n\t\t\t\t\t\t\tif (result.dynamic) continue\n\t\t\t\t\t\t\tconst output = result.output as {\n\t\t\t\t\t\t\t\tstatus?: string\n\t\t\t\t\t\t\t\tmessage?: string\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (output?.message) {\n\t\t\t\t\t\t\t\tconsole.log(`   ${output.message}`)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastStep.text) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`   Generated text: ${lastStep.text.substring(0, 100)}${lastStep.text.length > 100 ? \"...\" : \"\"}`,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Continue if last step had tool calls (agent is still working)\n\t\t\tif (lastStep.toolCalls && lastStep.toolCalls.length > 0) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// Default: Agent generated text, so stop.\n\t\t\treturn true\n\t\t},\n\t})\n\n\treturn agent\n}\n"
		}
	]
}
