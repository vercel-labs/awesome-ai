{
	"name": "pages-to-app-router",
	"type": "registry:prompt",
	"title": "Pages To App Router",
	"description": "System prompt for Pages To App Router",
	"files": [
		{
			"path": "prompts/pages-to-app-router.ts",
			"type": "registry:prompt",
			"content": "export function prompt(): string {\n\treturn `\nAnalyze this Next.js project and create a comprehensive migration plan for converting from Pages Router to App Router.\n\n# Migration Requirements\n\n**Source:** Next.js Pages Router (pages/ directory)\n**Target:** Next.js App Router (app/ directory)\n\nThe App Router introduces React Server Components, nested layouts, and new data fetching patterns. I need a phased migration plan that maintains functionality throughout the process.\n\n# Todo Tracking\n\n**Use the todo tools to track migration progress.** Create todos for each migration phase and update them as analysis progresses. This ensures:\n- Clear visibility of what's been analyzed vs pending\n- Structured tracking of files to be migrated\n- Progress checkpoints for each phase\n- A checklist that can be handed off to the migration agent\n\nStructure your todos like:\n- \\`[Phase 1] Foundational Setup - Analyze _app.js, _document.js\\`\n- \\`[Phase 2] Route Migration - pages/index.js → app/page.tsx\\`\n- \\`[Phase 2] Route Migration - pages/blog/[slug].js → app/blog/[slug]/page.tsx\\`\n- \\`[Phase 3] API Routes - pages/api/users.js → app/api/users/route.ts\\`\n\nMark todos as in_progress when analyzing, completed when plan is finalized for that item.\n\n# What to Analyze\n\n1. **Pages Directory:** Identify all pages\n2. **API Routes:** Catalog all routes in pages/api/\n3. **Data Fetching:** Document usage of getStaticProps, getServerSideProps, getStaticPaths, getInitialProps\n4. **Special Files:** Review _app.js, _document.js, _error.js, 404.js, 500.js\n5. **Middleware:** Check for middleware.ts and its route matchers\n\n# Quality Assurance Requirements\n\nFor each file/route analyzed, document:\n\n1. **Data Dependencies:** What data does it fetch? From where? With what caching?\n2. **Client-Side Interactivity:** What requires 'use client'? (state, effects, event handlers)\n3. **Test Coverage:** Are there existing tests? What needs test updates?\n4. **Breaking Change Risk:** What could break during the migration?\n\n## Verification Checkpoints\n\nEach phase should include verification steps:\n\n- [ ] All files in phase cataloged\n- [ ] Data fetching patterns identified and transformation planned\n- [ ] Client/Server component boundaries determined\n- [ ] TypeScript types preservation strategy defined\n- [ ] Potential breaking changes documented\n- [ ] Testing approach specified\n\n## Dependency Compatibility\n\nCheck for these common compatibility issues:\n- next-auth: Requires App Router-specific configuration\n- styled-components/emotion: Need 'use client' wrapper setup\n- react-query/swr: May need client component boundaries\n- i18n libraries or Next.js built-in i18n: Different setup for App Router\n- Custom webpack configurations in next.config.js\n\n# Component Boundary Analysis\n\nCreate a **Server/Client Component Tree** for each route. This is critical for App Router success:\n\n\\`\\`\\`\nRoute: /dashboard\n├── layout.tsx (Server) - fetches user session\n│   ├── Sidebar.tsx (Client) - has useState for collapse\n│   │   └── NavLinks.tsx (Server) - static navigation\n│   └── {children}\n│       └── page.tsx (Server) - fetches dashboard data\n│           ├── StatsGrid.tsx (Server) - displays metrics\n│           └── ActivityFeed.tsx (Client) - real-time updates, useEffect\n\\`\\`\\`\n\nFor each component, document:\n- **Why Server or Client?** - Justify the boundary decision\n- **Props passed across boundary** - Must be serializable for Server→Client\n- **Data fetching location** - Move to nearest Server Component ancestor\n\n# SEO & Metadata Audit\n\nApp Router uses the Metadata API instead of next/head. Audit:\n\n1. **Page-level metadata:** Title, description, openGraph, twitter cards\n2. **Dynamic metadata:** generateMetadata for dynamic routes\n3. **Structured data:** JSON-LD scripts that need migration\n4. **Canonical URLs:** Ensure proper canonical handling\n5. **Robots/sitemap:** Check for custom implementations\n\nCreate a metadata migration map:\n| Route | Current (next/head) | Target (Metadata API) | Dynamic? |\n|-------|--------------------|-----------------------|----------|\n| /home | title, description | metadata export | No |\n| /blog/[slug] | dynamic title | generateMetadata | Yes |\n\n# Rendering Strategy Audit\n\nDocument current rendering behavior and ensure it's preserved:\n\n| Route | Current Strategy | Data Pattern | App Router Equivalent |\n|-------|-----------------|--------------|----------------------|\n| /home | SSG | getStaticProps | Static Server Component |\n| /dashboard | SSR | getServerSideProps | Dynamic Server Component |\n| /blog/[slug] | ISR (60s) | getStaticProps + revalidate | fetch with revalidate: 60 |\n| /products | CSR | useEffect + fetch | Client Component or Route Handler |\n\n**Critical:** Changing rendering strategy can affect:\n- Time to First Byte (TTFB)\n- Caching behavior at CDN\n- Database/API load patterns\n- User experience during navigation\n\n# Migration Phases to Plan\n\n## Phase 1: Foundational Setup\n- Create app/ directory and root layout (app/layout.tsx)\n- Migrate _app.js: global styles, providers (as Client Components), metadata\n- Migrate _document.js: HTML structure, fonts (next/font)\n- Create app/not-found.tsx (from 404.js)\n- Create app/error.tsx (from _error.js, 500.js) - requires 'use client'\n- Create app/loading.tsx (optional)\n\n## Phase 2: Route Migration (order by complexity)\nStatic pages first, then dynamic routes, then catch-all routes.\n\n## Phase 3: API Routes\nConvert to Route Handlers with named HTTP method exports.\n\n## Phase 4: Layout Optimization\nIdentify shared layouts and create nested layout structure.\n\n## Phase 5: Special Features\n- Update middleware route matchers\n- Update next.config.js redirects/rewrites\n- Ensure next/image and next/font usage\n\n## Phase 6: Cleanup\nRemove pages/ directory after verification.\n\n# Transformation Patterns Reference\n\n## Routing\n| Pages Router | App Router |\n|-------------|------------|\n| pages/*.js | app/*/page.js |\n| pages/[id].js | app/[id]/page.js |\n| pages/[...slug].js | app/[...slug]/page.js |\n| pages/[[...slug]].js | app/[[...slug]]/page.js |\n| pages/api/*.js | app/api/*/route.js |\n\n## Data Fetching\n\n**getServerSideProps → async Server Component:**\n\\`\\`\\`typescript\n// Before\nexport async function getServerSideProps() {\n  const data = await fetchData()\n  return { props: { data } }\n}\n\n// After\nexport default async function Page() {\n  const data = await fetchData()\n  return <Component data={data} />\n}\n\\`\\`\\`\n\n**getStaticProps → Server Component with caching:**\n\\`\\`\\`typescript\n// Before\nexport async function getStaticProps() {\n  const data = await fetchData()\n  return { props: { data }, revalidate: 60 }\n}\n\n// After\nexport default async function Page() {\n  const data = await fetch(url, { next: { revalidate: 60 } })\n  return <Component data={data} />\n}\n\\`\\`\\`\n\n**getStaticPaths → generateStaticParams:**\n\\`\\`\\`typescript\n// Before\nexport async function getStaticPaths() {\n  const paths = await getPaths()\n  return { paths, fallback: false }\n}\n\n// After\nexport async function generateStaticParams() {\n  const paths = await getPaths()\n  return paths.map(p => ({ slug: p.slug }))\n}\n\\`\\`\\`\n\n## Special Files\n| Pages Router | App Router |\n|-------------|------------|\n| _app.js | layout.js (root layout) |\n| _document.js | layout.js (HTML + metadata API) |\n| _error.js | error.tsx ('use client') |\n| 404.js | not-found.tsx |\n| 500.js | error.tsx |\n\n## Component Patterns\n\n**Server Components (default):** No directive needed.\n\n**Client Components:** Add 'use client' when using:\n- useState, useEffect, useContext\n- Event handlers (onClick, onChange)\n- Browser APIs (localStorage, window)\n\n**Provider extraction:**\n\\`\\`\\`typescript\n// app/providers.tsx\n'use client'\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return <ThemeProvider><AuthProvider>{children}</AuthProvider></ThemeProvider>\n}\n\n// app/layout.tsx\nimport { Providers } from './providers'\nexport default function RootLayout({ children }) {\n  return <html><body><Providers>{children}</Providers></body></html>\n}\n\\`\\`\\`\n\n## API Route Handlers\n\\`\\`\\`typescript\n// app/api/users/route.ts\nimport { NextRequest, NextResponse } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  return NextResponse.json(await getUsers())\n}\n\nexport async function POST(request: NextRequest) {\n  const body = await request.json()\n  return NextResponse.json(await createUser(body), { status: 201 })\n}\n\\`\\`\\`\n\n# Important Considerations\n\n- Pages Router and App Router can coexist during migration\n- Test after each phase before proceeding\n- Commit after each successful migration step\n- Watch for hydration mismatches at Server/Client boundaries\n- Update middleware route matchers for app/ paths\n- Client-side env vars need NEXT_PUBLIC_ prefix\n- **Preserve all TypeScript types** - don't lose type safety\n- **Verify functionality parity** - migrated routes must behave identically\n- **Document any behavior changes** - if something must change, note it explicitly\n\n# Output Requirements\n\nPlease analyze the project and create a detailed, phased migration plan. Use todos to track your analysis progress. For each phase include:\n\n1. **Specific files to modify** with transformation notes\n2. **Component boundary tree** showing Server/Client decisions\n3. **Metadata migration map** for SEO preservation\n4. **Rendering strategy table** ensuring behavior parity\n5. **Estimated effort** (time estimate)\n6. **Risk level** (Low/Medium/High) with justification\n7. **Verification steps** to confirm successful migration\n`.trim()\n}\n"
		}
	]
}
