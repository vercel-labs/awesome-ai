{
	"name": "bash",
	"type": "registry:tool",
	"title": "Bash",
	"description": "Executes shell commands with real-time output streaming.",
	"dependencies": [
		"ai",
		"zod"
	],
	"registryDependencies": [
		"agents:lib/permissions"
	],
	"files": [
		{
			"path": "tools/bash.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { spawn } from \"child_process\"\nimport { z } from \"zod\"\nimport {\n\tcheckPermission,\n\tDEFAULT_BASH_PERMISSIONS,\n\ttype Permission,\n\tPermissionDeniedError,\n} from \"@/agents/lib/permissions\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\n\nconst MAX_OUTPUT_LENGTH = 30_000\nconst DEFAULT_TIMEOUT = 1 * 60 * 1000 // 1 minute\nconst MAX_TIMEOUT = 10 * 60 * 1000 // 10 minutes\nconst SIGKILL_DELAY_MS = 200 // Wait before sending SIGKILL\nconst STREAM_THROTTLE_MS = 100 // Minimum time between streaming updates\n\n/**\n * Detect the appropriate shell to use based on platform and environment\n */\nfunction detectShell(): string | boolean {\n\tconst envShell = process.env.SHELL\n\n\t// Use environment shell if available, but skip fish/nu (not POSIX compatible)\n\tif (envShell) {\n\t\tconst unsupportedShells = new Set([\n\t\t\t\"/bin/fish\",\n\t\t\t\"/bin/nu\",\n\t\t\t\"/usr/bin/fish\",\n\t\t\t\"/usr/bin/nu\",\n\t\t\t\"/usr/local/bin/fish\",\n\t\t\t\"/usr/local/bin/nu\",\n\t\t])\n\t\tif (!unsupportedShells.has(envShell)) {\n\t\t\treturn envShell\n\t\t}\n\t}\n\n\t// Platform-specific defaults\n\tif (process.platform === \"darwin\") {\n\t\treturn \"/bin/zsh\"\n\t}\n\n\tif (process.platform === \"win32\") {\n\t\treturn process.env.COMSPEC || \"cmd.exe\"\n\t}\n\n\t// Linux/other: try to find bash\n\treturn \"/bin/bash\"\n}\n\nfunction sleep(ms: number): Promise<void> {\n\treturn new Promise((resolve) => setTimeout(resolve, ms))\n}\n\n/**\n * Kill a process tree (process group on Unix, taskkill on Windows)\n */\nasync function killProcessTree(\n\tproc: ReturnType<typeof spawn>,\n\texited: { value: boolean },\n): Promise<void> {\n\tconst pid = proc.pid\n\tif (!pid || exited.value) {\n\t\treturn\n\t}\n\n\tif (process.platform === \"win32\") {\n\t\t// Windows: use taskkill to kill process tree\n\t\tawait new Promise<void>((resolve) => {\n\t\t\tconst killer = spawn(\"taskkill\", [\"/pid\", String(pid), \"/f\", \"/t\"], {\n\t\t\t\tstdio: \"ignore\",\n\t\t\t})\n\t\t\tkiller.once(\"exit\", () => resolve())\n\t\t\tkiller.once(\"error\", () => resolve())\n\t\t})\n\t\treturn\n\t}\n\n\t// Unix: kill process group with SIGTERM, then SIGKILL if needed\n\ttry {\n\t\t// Try to kill the process group (negative PID)\n\t\tprocess.kill(-pid, \"SIGTERM\")\n\t\tawait sleep(SIGKILL_DELAY_MS)\n\n\t\tif (!exited.value) {\n\t\t\tprocess.kill(-pid, \"SIGKILL\")\n\t\t}\n\t} catch {\n\t\t// Fallback: kill just the process if process group fails\n\t\ttry {\n\t\t\tproc.kill(\"SIGTERM\")\n\t\t\tawait sleep(SIGKILL_DELAY_MS)\n\n\t\t\tif (!exited.value) {\n\t\t\t\tproc.kill(\"SIGKILL\")\n\t\t\t}\n\t\t} catch {\n\t\t\t// Process already dead\n\t\t}\n\t}\n}\n\nconst shell = detectShell()\n\nconst description = `Executes shell commands with real-time output streaming.\n\nUsage:\n- Commands are executed in the current working directory\n- Output is streamed in real-time as it's produced\n- Commands have a default timeout of 1 minute, maximum 10 minutes\n- Output is truncated if it exceeds 30,000 characters\n- Use this tool for running builds, tests, installations, git commands, etc.\n- On timeout, processes are gracefully terminated (SIGTERM, then SIGKILL)`\n\nconst inputSchema = z.object({\n\tcommand: z.string().describe(\"The command to execute\"),\n\ttimeout: z.number().optional().describe(\"Optional timeout in milliseconds\"),\n\tdescription: z\n\t\t.string()\n\t\t.describe(\n\t\t\t\"Clear, concise description of what this command does in 5-10 words\",\n\t\t),\n})\n\nconst outputSchema = toolOutput({\n\tpending: {\n\t\tcommand: z.string(),\n\t\tdescription: z.string(),\n\t\toutput: z.undefined(),\n\t},\n\tstreaming: {\n\t\tcommand: z.string(),\n\t\tdescription: z.string(),\n\t\toutput: z.string(),\n\t},\n\tsuccess: {\n\t\tcommand: z.string(),\n\t\tdescription: z.string(),\n\t\toutput: z.string(),\n\t\texitCode: z.number(),\n\t\ttimedOut: z.boolean().optional(),\n\t},\n\terror: {\n\t\tcommand: z.string(),\n\t\tdescription: z.string(),\n\t},\n})\n\n/**\n * Create a bash tool with custom permission patterns.\n *\n * @param permissions - Command pattern to permission mapping. Patterns support\n * wildcards (*) for matching. Default allows safe read-only commands.\n *\n * @example\n * // Allow all git commands without approval\n * const gitBash = createBashTool({\n *   ...DEFAULT_BASH_PERMISSIONS,\n *   \"git *\": \"allow\",\n * })\n *\n * @example\n * // Require approval for everything\n * const strictBash = createBashTool({ \"*\": \"ask\" })\n */\nexport function createBashTool(\n\tpermissions: Record<string, Permission> = DEFAULT_BASH_PERMISSIONS,\n) {\n\treturn tool({\n\t\tdescription,\n\t\tinputSchema,\n\t\toutputSchema,\n\t\tneedsApproval: ({ command }) => {\n\t\t\tconst permission = checkPermission(command, permissions)\n\n\t\t\tif (permission === \"deny\") {\n\t\t\t\tthrow new PermissionDeniedError(\"bash\", command)\n\t\t\t}\n\n\t\t\t// Return true if approval needed (ask), false if auto-allowed\n\t\t\treturn permission === \"ask\"\n\t\t},\n\t\ttoModelOutput: (output) => {\n\t\t\tif (output.status === \"error\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"error-text\",\n\t\t\t\t\tvalue: `Error executing \"${output.command}\": ${output.error}`,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output.status === \"success\") {\n\t\t\t\treturn { type: \"text\", value: output.output }\n\t\t\t}\n\t\t\t// For streaming/pending, don't send to model yet\n\t\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t\t},\n\t\tasync *execute({ command, timeout, description: desc }) {\n\t\t\t// Validate and constrain timeout\n\t\t\tif (timeout !== undefined && timeout < 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid timeout value: ${timeout}. Timeout must be a positive number.`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tconst effectiveTimeout = Math.min(timeout ?? DEFAULT_TIMEOUT, MAX_TIMEOUT)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"pending\",\n\t\t\t\tmessage: `Running: ${command}`,\n\t\t\t\tcommand,\n\t\t\t\tdescription: desc,\n\t\t\t\toutput: undefined,\n\t\t\t}\n\n\t\t\t// Use an async iterator pattern with events\n\t\t\tconst proc = spawn(command, {\n\t\t\t\tshell,\n\t\t\t\tcwd: process.cwd(),\n\t\t\t\tenv: process.env,\n\t\t\t\tstdio: [\"ignore\", \"pipe\", \"pipe\"],\n\t\t\t\t// Detach on Unix to create process group for clean killing\n\t\t\t\tdetached: process.platform !== \"win32\",\n\t\t\t})\n\n\t\t\tlet output = \"\"\n\t\t\tlet timedOut = false\n\t\t\tconst exited = { value: false }\n\t\t\tlet lastStreamTime = 0\n\n\t\t\t// Create a queue for streaming updates\n\t\t\tconst streamQueue: string[] = []\n\t\t\tlet resolveStream: (() => void) | null = null\n\n\t\t\tconst queueStreamUpdate = () => {\n\t\t\t\tconst now = Date.now()\n\t\t\t\t// Throttle updates to avoid overwhelming\n\t\t\t\tif (now - lastStreamTime >= STREAM_THROTTLE_MS) {\n\t\t\t\t\tlastStreamTime = now\n\t\t\t\t\tstreamQueue.push(output)\n\t\t\t\t\tif (resolveStream) {\n\t\t\t\t\t\tresolveStream()\n\t\t\t\t\t\tresolveStream = null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Capture stdout\n\t\t\tproc.stdout?.on(\"data\", (chunk: Buffer) => {\n\t\t\t\toutput += chunk.toString()\n\t\t\t\tqueueStreamUpdate()\n\t\t\t})\n\n\t\t\t// Capture stderr\n\t\t\tproc.stderr?.on(\"data\", (chunk: Buffer) => {\n\t\t\t\toutput += chunk.toString()\n\t\t\t\tqueueStreamUpdate()\n\t\t\t})\n\n\t\t\t// Set up timeout\n\t\t\tconst timeoutTimer = setTimeout(() => {\n\t\t\t\ttimedOut = true\n\t\t\t\tvoid killProcessTree(proc, exited)\n\t\t\t}, effectiveTimeout)\n\n\t\t\t// Create promise for process completion\n\t\t\tconst exitPromise = new Promise<number | null>((resolve, reject) => {\n\t\t\t\tproc.once(\"close\", (code) => {\n\t\t\t\t\texited.value = true\n\t\t\t\t\tclearTimeout(timeoutTimer)\n\t\t\t\t\t// Signal any pending stream wait\n\t\t\t\t\tif (resolveStream) {\n\t\t\t\t\t\tresolveStream()\n\t\t\t\t\t\tresolveStream = null\n\t\t\t\t\t}\n\t\t\t\t\tresolve(code)\n\t\t\t\t})\n\n\t\t\t\tproc.once(\"error\", (error) => {\n\t\t\t\t\texited.value = true\n\t\t\t\t\tclearTimeout(timeoutTimer)\n\t\t\t\t\tif (resolveStream) {\n\t\t\t\t\t\tresolveStream()\n\t\t\t\t\t\tresolveStream = null\n\t\t\t\t\t}\n\t\t\t\t\treject(new Error(`Failed to execute command: ${error.message}`))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Stream output while process is running\n\t\t\ttry {\n\t\t\t\twhile (!exited.value) {\n\t\t\t\t\t// Wait for either new output or process exit\n\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\tnew Promise<void>((resolve) => {\n\t\t\t\t\t\t\tresolveStream = resolve\n\t\t\t\t\t\t}),\n\t\t\t\t\t\texitPromise.catch(() => {}), // Don't throw here, handle below\n\t\t\t\t\t\tsleep(STREAM_THROTTLE_MS * 2), // Fallback timeout\n\t\t\t\t\t])\n\n\t\t\t\t\t// Yield streaming update if we have new output\n\t\t\t\t\tif (streamQueue.length > 0) {\n\t\t\t\t\t\tconst latestOutput = streamQueue[streamQueue.length - 1]!\n\t\t\t\t\t\tstreamQueue.length = 0 // Clear queue\n\n\t\t\t\t\t\t// Only yield if we have actual content\n\t\t\t\t\t\tif (latestOutput.length > 0) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tstatus: \"streaming\",\n\t\t\t\t\t\t\t\tmessage: `Running: ${command}`,\n\t\t\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\t\tdescription: desc,\n\t\t\t\t\t\t\t\toutput: latestOutput,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wait for exit and get code\n\t\t\t\tconst exitCode = await exitPromise\n\n\t\t\t\t// Truncate output if too long\n\t\t\t\tif (output.length > MAX_OUTPUT_LENGTH) {\n\t\t\t\t\toutput = output.slice(0, MAX_OUTPUT_LENGTH)\n\t\t\t\t\toutput += \"\\n\\n(Output was truncated due to length limit)\"\n\t\t\t\t}\n\n\t\t\t\t// Add timeout notice\n\t\t\t\tif (timedOut) {\n\t\t\t\t\toutput += `\\n\\n(Command timed out after ${effectiveTimeout}ms)`\n\t\t\t\t}\n\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\tmessage: `Command completed with exit code ${exitCode ?? -1}`,\n\t\t\t\t\tcommand,\n\t\t\t\t\tdescription: desc,\n\t\t\t\t\toutput: `Command: ${command}\\nDescription: ${desc}\\nExit code: ${exitCode ?? -1}\\n\\n${output}`,\n\t\t\t\t\texitCode: exitCode ?? -1,\n\t\t\t\t\ttimedOut: timedOut || undefined,\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: `Failed to execute: ${command}`,\n\t\t\t\t\tcommand,\n\t\t\t\t\tdescription: desc,\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n}\n\n/**\n * Default bash tool with standard permissions.\n * Safe read-only commands are auto-allowed, others require approval.\n */\nexport const bashTool = createBashTool()\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		}
	]
}
