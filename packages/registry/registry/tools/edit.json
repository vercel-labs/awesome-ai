{
	"name": "edit",
	"type": "registry:tool",
	"title": "Edit",
	"description": "Performs string replacements in files with fuzzy matching.",
	"dependencies": ["ai", "diff", "zod"],
	"registryDependencies": ["agents:lib/permissions"],
	"files": [
		{
			"path": "tools/edit.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { createTwoFilesPatch } from \"diff\"\nimport { promises as fs } from \"fs\"\nimport * as path from \"path\"\nimport { z } from \"zod\"\nimport {\n\tcheckPermission,\n\ttype Permission,\n\tPermissionDeniedError,\n} from \"@/agents/lib/permissions\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\nimport { trimDiff } from \"@/tools/lib/trim-diff\"\n\n// ============================================================================\n// Replacement Strategies\n// These strategies are sourced from:\n// - https://github.com/sst/opencode/blob/dev/packages/opencode/src/tool/edit.ts\n// - https://github.com/cline/cline/blob/main/evals/diff-edits/diff-apply/diff-06-23-25.ts\n// - https://github.com/google-gemini/gemini-cli/blob/main/packages/core/src/utils/editCorrector.ts\n// ============================================================================\n\n/**\n * A replacer is a generator that yields possible matches for a search string.\n * Each yielded string is a candidate that might be found in the content.\n */\nexport type Replacer = (\n\tcontent: string,\n\tfind: string,\n) => Generator<string, void, unknown>\n\n// Similarity thresholds for block anchor fallback matching\nconst SINGLE_CANDIDATE_SIMILARITY_THRESHOLD = 0.0\nconst MULTIPLE_CANDIDATES_SIMILARITY_THRESHOLD = 0.3\n\n/**\n * Levenshtein distance algorithm for fuzzy string matching\n */\nfunction levenshtein(a: string, b: string): number {\n\tif (a === \"\" || b === \"\") {\n\t\treturn Math.max(a.length, b.length)\n\t}\n\n\tconst matrix = Array.from({ length: a.length + 1 }, (_, i) =>\n\t\tArray.from({ length: b.length + 1 }, (_, j) =>\n\t\t\ti === 0 ? j : j === 0 ? i : 0,\n\t\t),\n\t)\n\n\tfor (let i = 1; i <= a.length; i++) {\n\t\tfor (let j = 1; j <= b.length; j++) {\n\t\t\tconst cost = a[i - 1] === b[j - 1] ? 0 : 1\n\t\t\tmatrix[i]![j] = Math.min(\n\t\t\t\tmatrix[i - 1]![j]! + 1,\n\t\t\t\tmatrix[i]![j - 1]! + 1,\n\t\t\t\tmatrix[i - 1]![j - 1]! + cost,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn matrix[a.length]![b.length]!\n}\n\n/**\n * Strategy 1: Simple exact match\n */\nexport const SimpleReplacer: Replacer = function* (_content, find) {\n\tyield find\n}\n\n/**\n * Strategy 2: Line-trimmed match\n * Matches content where each line's trimmed version matches\n */\nexport const LineTrimmedReplacer: Replacer = function* (content, find) {\n\tconst originalLines = content.split(\"\\n\")\n\tconst searchLines = find.split(\"\\n\")\n\n\tif (searchLines[searchLines.length - 1] === \"\") {\n\t\tsearchLines.pop()\n\t}\n\n\tfor (let i = 0; i <= originalLines.length - searchLines.length; i++) {\n\t\tlet matches = true\n\n\t\tfor (let j = 0; j < searchLines.length; j++) {\n\t\t\tconst originalTrimmed = originalLines[i + j]?.trim()\n\t\t\tconst searchTrimmed = searchLines[j]?.trim()\n\n\t\t\tif (originalTrimmed !== searchTrimmed) {\n\t\t\t\tmatches = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (matches) {\n\t\t\tlet matchStartIndex = 0\n\t\t\tfor (let k = 0; k < i; k++) {\n\t\t\t\tmatchStartIndex += originalLines[k]!.length + 1\n\t\t\t}\n\n\t\t\tlet matchEndIndex = matchStartIndex\n\t\t\tfor (let k = 0; k < searchLines.length; k++) {\n\t\t\t\tmatchEndIndex += originalLines[i + k]!.length\n\t\t\t\tif (k < searchLines.length - 1) {\n\t\t\t\t\tmatchEndIndex += 1\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tyield content.substring(matchStartIndex, matchEndIndex)\n\t\t}\n\t}\n}\n\n/**\n * Strategy 3: Block anchor matching with Levenshtein distance\n * Matches blocks by first/last line with fuzzy middle content\n */\nexport const BlockAnchorReplacer: Replacer = function* (content, find) {\n\tconst originalLines = content.split(\"\\n\")\n\tconst searchLines = find.split(\"\\n\")\n\n\tif (searchLines.length < 3) {\n\t\treturn\n\t}\n\n\tif (searchLines[searchLines.length - 1] === \"\") {\n\t\tsearchLines.pop()\n\t}\n\n\tconst firstLineSearch = searchLines[0]!.trim()\n\tconst lastLineSearch = searchLines[searchLines.length - 1]!.trim()\n\tconst searchBlockSize = searchLines.length\n\n\t// Collect all candidate positions where both anchors match\n\tconst candidates: Array<{ startLine: number; endLine: number }> = []\n\tfor (let i = 0; i < originalLines.length; i++) {\n\t\tif (originalLines[i]!.trim() !== firstLineSearch) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Look for the matching last line after this first line\n\t\tfor (let j = i + 2; j < originalLines.length; j++) {\n\t\t\tif (originalLines[j]!.trim() === lastLineSearch) {\n\t\t\t\tcandidates.push({ startLine: i, endLine: j })\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif (candidates.length === 0) {\n\t\treturn\n\t}\n\n\t// Handle single candidate scenario (using relaxed threshold)\n\tif (candidates.length === 1) {\n\t\tconst { startLine, endLine } = candidates[0]!\n\t\tconst actualBlockSize = endLine - startLine + 1\n\n\t\tlet similarity = 0\n\t\tconst linesToCheck = Math.min(searchBlockSize - 2, actualBlockSize - 2)\n\n\t\tif (linesToCheck > 0) {\n\t\t\tfor (let j = 1; j < searchBlockSize - 1 && j < actualBlockSize - 1; j++) {\n\t\t\t\tconst originalLine = originalLines[startLine + j]!.trim()\n\t\t\t\tconst searchLine = searchLines[j]!.trim()\n\t\t\t\tconst maxLen = Math.max(originalLine.length, searchLine.length)\n\t\t\t\tif (maxLen === 0) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst distance = levenshtein(originalLine, searchLine)\n\t\t\t\tsimilarity += (1 - distance / maxLen) / linesToCheck\n\n\t\t\t\tif (similarity >= SINGLE_CANDIDATE_SIMILARITY_THRESHOLD) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsimilarity = 1.0\n\t\t}\n\n\t\tif (similarity >= SINGLE_CANDIDATE_SIMILARITY_THRESHOLD) {\n\t\t\tlet matchStartIndex = 0\n\t\t\tfor (let k = 0; k < startLine; k++) {\n\t\t\t\tmatchStartIndex += originalLines[k]!.length + 1\n\t\t\t}\n\t\t\tlet matchEndIndex = matchStartIndex\n\t\t\tfor (let k = startLine; k <= endLine; k++) {\n\t\t\t\tmatchEndIndex += originalLines[k]!.length\n\t\t\t\tif (k < endLine) {\n\t\t\t\t\tmatchEndIndex += 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tyield content.substring(matchStartIndex, matchEndIndex)\n\t\t}\n\t\treturn\n\t}\n\n\t// Calculate similarity for multiple candidates\n\tlet bestMatch: { startLine: number; endLine: number } | null = null\n\tlet maxSimilarity = -1\n\n\tfor (const candidate of candidates) {\n\t\tconst { startLine, endLine } = candidate\n\t\tconst actualBlockSize = endLine - startLine + 1\n\n\t\tlet similarity = 0\n\t\tconst linesToCheck = Math.min(searchBlockSize - 2, actualBlockSize - 2)\n\n\t\tif (linesToCheck > 0) {\n\t\t\tfor (let j = 1; j < searchBlockSize - 1 && j < actualBlockSize - 1; j++) {\n\t\t\t\tconst originalLine = originalLines[startLine + j]!.trim()\n\t\t\t\tconst searchLine = searchLines[j]!.trim()\n\t\t\t\tconst maxLen = Math.max(originalLine.length, searchLine.length)\n\t\t\t\tif (maxLen === 0) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst distance = levenshtein(originalLine, searchLine)\n\t\t\t\tsimilarity += 1 - distance / maxLen\n\t\t\t}\n\t\t\tsimilarity /= linesToCheck\n\t\t} else {\n\t\t\tsimilarity = 1.0\n\t\t}\n\n\t\tif (similarity > maxSimilarity) {\n\t\t\tmaxSimilarity = similarity\n\t\t\tbestMatch = candidate\n\t\t}\n\t}\n\n\tif (maxSimilarity >= MULTIPLE_CANDIDATES_SIMILARITY_THRESHOLD && bestMatch) {\n\t\tconst { startLine, endLine } = bestMatch\n\t\tlet matchStartIndex = 0\n\t\tfor (let k = 0; k < startLine; k++) {\n\t\t\tmatchStartIndex += originalLines[k]!.length + 1\n\t\t}\n\t\tlet matchEndIndex = matchStartIndex\n\t\tfor (let k = startLine; k <= endLine; k++) {\n\t\t\tmatchEndIndex += originalLines[k]!.length\n\t\t\tif (k < endLine) {\n\t\t\t\tmatchEndIndex += 1\n\t\t\t}\n\t\t}\n\t\tyield content.substring(matchStartIndex, matchEndIndex)\n\t}\n}\n\n/**\n * Strategy 4: Whitespace normalized matching\n * Collapses multiple spaces/tabs to single space\n */\nexport const WhitespaceNormalizedReplacer: Replacer = function* (\n\tcontent,\n\tfind,\n) {\n\tconst normalizeWhitespace = (text: string) => text.replace(/\\s+/g, \" \").trim()\n\tconst normalizedFind = normalizeWhitespace(find)\n\n\tconst lines = content.split(\"\\n\")\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i]!\n\t\tif (normalizeWhitespace(line) === normalizedFind) {\n\t\t\tyield line\n\t\t} else {\n\t\t\tconst normalizedLine = normalizeWhitespace(line)\n\t\t\tif (normalizedLine.includes(normalizedFind)) {\n\t\t\t\tconst words = find.trim().split(/\\s+/)\n\t\t\t\tif (words.length > 0) {\n\t\t\t\t\tconst pattern = words\n\t\t\t\t\t\t.map((word) => word.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"))\n\t\t\t\t\t\t.join(\"\\\\s+\")\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst regex = new RegExp(pattern)\n\t\t\t\t\t\tconst match = line.match(regex)\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tyield match[0]\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Invalid regex pattern, skip\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Handle multi-line matches\n\tconst findLines = find.split(\"\\n\")\n\tif (findLines.length > 1) {\n\t\tfor (let i = 0; i <= lines.length - findLines.length; i++) {\n\t\t\tconst block = lines.slice(i, i + findLines.length)\n\t\t\tif (normalizeWhitespace(block.join(\"\\n\")) === normalizedFind) {\n\t\t\t\tyield block.join(\"\\n\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Strategy 5: Indentation flexible matching\n * Matches content regardless of indentation level\n */\nexport const IndentationFlexibleReplacer: Replacer = function* (content, find) {\n\tconst removeIndentation = (text: string) => {\n\t\tconst lines = text.split(\"\\n\")\n\t\tconst nonEmptyLines = lines.filter((line) => line.trim().length > 0)\n\t\tif (nonEmptyLines.length === 0) return text\n\n\t\tconst minIndent = Math.min(\n\t\t\t...nonEmptyLines.map((line) => {\n\t\t\t\tconst match = line.match(/^(\\s*)/)\n\t\t\t\treturn match ? match[1]!.length : 0\n\t\t\t}),\n\t\t)\n\n\t\treturn lines\n\t\t\t.map((line) => (line.trim().length === 0 ? line : line.slice(minIndent)))\n\t\t\t.join(\"\\n\")\n\t}\n\n\tconst normalizedFind = removeIndentation(find)\n\tconst contentLines = content.split(\"\\n\")\n\tconst findLines = find.split(\"\\n\")\n\n\tfor (let i = 0; i <= contentLines.length - findLines.length; i++) {\n\t\tconst block = contentLines.slice(i, i + findLines.length).join(\"\\n\")\n\t\tif (removeIndentation(block) === normalizedFind) {\n\t\t\tyield block\n\t\t}\n\t}\n}\n\n/**\n * Strategy 6: Escape normalized matching\n * Handles escape sequences like \\n, \\t in search strings\n */\nexport const EscapeNormalizedReplacer: Replacer = function* (content, find) {\n\tconst unescapeString = (str: string): string => {\n\t\treturn str.replace(\n\t\t\t/\\\\(n|t|r|'|\"|`|\\\\|\\n|\\$)/g,\n\t\t\t(match, capturedChar: string) => {\n\t\t\t\tswitch (capturedChar) {\n\t\t\t\t\tcase \"n\":\n\t\t\t\t\t\treturn \"\\n\"\n\t\t\t\t\tcase \"t\":\n\t\t\t\t\t\treturn \"\\t\"\n\t\t\t\t\tcase \"r\":\n\t\t\t\t\t\treturn \"\\r\"\n\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\treturn \"'\"\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\treturn '\"'\n\t\t\t\t\tcase \"`\":\n\t\t\t\t\t\treturn \"`\"\n\t\t\t\t\tcase \"\\\\\":\n\t\t\t\t\t\treturn \"\\\\\"\n\t\t\t\t\tcase \"\\n\":\n\t\t\t\t\t\treturn \"\\n\"\n\t\t\t\t\tcase \"$\":\n\t\t\t\t\t\treturn \"$\"\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn match\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n\n\tconst unescapedFind = unescapeString(find)\n\n\tif (content.includes(unescapedFind)) {\n\t\tyield unescapedFind\n\t}\n\n\tconst lines = content.split(\"\\n\")\n\tconst findLines = unescapedFind.split(\"\\n\")\n\n\tfor (let i = 0; i <= lines.length - findLines.length; i++) {\n\t\tconst block = lines.slice(i, i + findLines.length).join(\"\\n\")\n\t\tconst unescapedBlock = unescapeString(block)\n\n\t\tif (unescapedBlock === unescapedFind) {\n\t\t\tyield block\n\t\t}\n\t}\n}\n\n/**\n * Strategy 7: Trimmed boundary matching\n * Matches trimmed versions of the search string\n */\nexport const TrimmedBoundaryReplacer: Replacer = function* (content, find) {\n\tconst trimmedFind = find.trim()\n\n\tif (trimmedFind === find) {\n\t\treturn\n\t}\n\n\tif (content.includes(trimmedFind)) {\n\t\tyield trimmedFind\n\t}\n\n\tconst lines = content.split(\"\\n\")\n\tconst findLines = find.split(\"\\n\")\n\n\tfor (let i = 0; i <= lines.length - findLines.length; i++) {\n\t\tconst block = lines.slice(i, i + findLines.length).join(\"\\n\")\n\n\t\tif (block.trim() === trimmedFind) {\n\t\t\tyield block\n\t\t}\n\t}\n}\n\n/**\n * Strategy 8: Context-aware matching\n * Uses first/last lines as context anchors with similarity check\n */\nexport const ContextAwareReplacer: Replacer = function* (content, find) {\n\tconst findLines = find.split(\"\\n\")\n\tif (findLines.length < 3) {\n\t\treturn\n\t}\n\n\tif (findLines[findLines.length - 1] === \"\") {\n\t\tfindLines.pop()\n\t}\n\n\tconst contentLines = content.split(\"\\n\")\n\tconst firstLine = findLines[0]!.trim()\n\tconst lastLine = findLines[findLines.length - 1]!.trim()\n\n\tfor (let i = 0; i < contentLines.length; i++) {\n\t\tif (contentLines[i]!.trim() !== firstLine) continue\n\n\t\tfor (let j = i + 2; j < contentLines.length; j++) {\n\t\t\tif (contentLines[j]!.trim() === lastLine) {\n\t\t\t\tconst blockLines = contentLines.slice(i, j + 1)\n\t\t\t\tconst block = blockLines.join(\"\\n\")\n\n\t\t\t\tif (blockLines.length === findLines.length) {\n\t\t\t\t\tlet matchingLines = 0\n\t\t\t\t\tlet totalNonEmptyLines = 0\n\n\t\t\t\t\tfor (let k = 1; k < blockLines.length - 1; k++) {\n\t\t\t\t\t\tconst blockLine = blockLines[k]!.trim()\n\t\t\t\t\t\tconst findLine = findLines[k]!.trim()\n\n\t\t\t\t\t\tif (blockLine.length > 0 || findLine.length > 0) {\n\t\t\t\t\t\t\ttotalNonEmptyLines++\n\t\t\t\t\t\t\tif (blockLine === findLine) {\n\t\t\t\t\t\t\t\tmatchingLines++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\ttotalNonEmptyLines === 0 ||\n\t\t\t\t\t\tmatchingLines / totalNonEmptyLines >= 0.5\n\t\t\t\t\t) {\n\t\t\t\t\t\tyield block\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Strategy 9: Multi-occurrence matching\n * Yields all exact matches for replaceAll scenarios\n */\nexport const MultiOccurrenceReplacer: Replacer = function* (content, find) {\n\tlet startIndex = 0\n\n\twhile (true) {\n\t\tconst index = content.indexOf(find, startIndex)\n\t\tif (index === -1) break\n\n\t\tyield find\n\t\tstartIndex = index + find.length\n\t}\n}\n\n/**\n * All replacement strategies in order of preference\n */\nconst REPLACERS: Replacer[] = [\n\tSimpleReplacer,\n\tLineTrimmedReplacer,\n\tBlockAnchorReplacer,\n\tWhitespaceNormalizedReplacer,\n\tIndentationFlexibleReplacer,\n\tEscapeNormalizedReplacer,\n\tTrimmedBoundaryReplacer,\n\tContextAwareReplacer,\n\tMultiOccurrenceReplacer,\n]\n\n/**\n * Try all replacement strategies to find and replace content\n */\nexport function replace(\n\tcontent: string,\n\toldString: string,\n\tnewString: string,\n\treplaceAll = false,\n): string {\n\tif (oldString === newString) {\n\t\tthrow new Error(\"oldString and newString must be different\")\n\t}\n\n\tlet notFound = true\n\n\tfor (const replacer of REPLACERS) {\n\t\tfor (const search of replacer(content, oldString)) {\n\t\t\tconst index = content.indexOf(search)\n\t\t\tif (index === -1) continue\n\n\t\t\tnotFound = false\n\n\t\t\tif (replaceAll) {\n\t\t\t\treturn content.replaceAll(search, newString)\n\t\t\t}\n\n\t\t\tconst lastIndex = content.lastIndexOf(search)\n\t\t\tif (index !== lastIndex) continue\n\n\t\t\treturn (\n\t\t\t\tcontent.substring(0, index) +\n\t\t\t\tnewString +\n\t\t\t\tcontent.substring(index + search.length)\n\t\t\t)\n\t\t}\n\t}\n\n\tif (notFound) {\n\t\tthrow new Error(\"oldString not found in content\")\n\t}\n\n\tthrow new Error(\n\t\t\"Found multiple matches for oldString. Provide more surrounding lines in oldString to identify the correct match.\",\n\t)\n}\n\n/**\n * Normalize line endings to Unix style\n */\nfunction normalizeLineEndings(text: string): string {\n\treturn text.replaceAll(\"\\r\\n\", \"\\n\")\n}\n\n// ============================================================================\n// Tool Definition\n// ============================================================================\n\nconst description = `Performs string replacements in files with fuzzy matching.\n\nUsage:\n- You must use your Read tool at least once in the conversation before editing. This tool will error if you attempt an edit without reading the file.\n- When editing text from Read tool output, ensure you preserve the exact indentation (tabs/spaces) as it appears AFTER the line number prefix. The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual file content to match. Never include any part of the line number prefix in the oldString or newString.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked.\n- The edit will FAIL if oldString is not found in the file with an error \"oldString not found in content\".\n- The edit will FAIL if oldString is found multiple times in the file with an error \"Found multiple matches for oldString\". Either provide a larger string with more surrounding context to make it unique or use replaceAll to change every instance of oldString.\n- Use replaceAll for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable for instance.\n\nMatching strategies (tried in order):\n1. Exact match\n2. Line-trimmed match (ignores leading/trailing whitespace per line)\n3. Block anchor match (first/last line anchors with fuzzy middle)\n4. Whitespace normalized match (collapses spaces/tabs)\n5. Indentation flexible match (ignores indentation level)\n6. Escape normalized match (handles \\\\n, \\\\t, etc.)\n7. Trimmed boundary match\n8. Context-aware match (uses surrounding lines)`\n\nconst inputSchema = z.object({\n\tfilePath: z.string().describe(\"The absolute path to the file to modify\"),\n\toldString: z.string().describe(\"The text to replace\"),\n\tnewString: z\n\t\t.string()\n\t\t.describe(\"The text to replace it with (must be different from oldString)\"),\n\treplaceAll: z\n\t\t.boolean()\n\t\t.optional()\n\t\t.describe(\"Replace all occurrences of oldString (default false)\"),\n})\n\nconst outputSchema = toolOutput({\n\tpending: {\n\t\tfilePath: z.string(),\n\t\tresult: z.undefined(),\n\t},\n\tsuccess: {\n\t\tfilePath: z.string(),\n\t\tresult: z.string(),\n\t\tdiff: z.string(),\n\t},\n\terror: {\n\t\tfilePath: z.string(),\n\t},\n})\n\n/**\n * Create an edit tool with custom permission patterns.\n *\n * @param permissions - File path pattern to permission mapping, or a single\n * permission for all files. Patterns support wildcards (*) for matching. By\n * default requires approval for all edits.\n *\n * @example\n * // Allow editing all .ts files without approval\n * const tsEdit = createEditTool({ \"*.ts\": \"allow\", \"*\": \"ask\" })\n *\n * @example\n * // Require approval for everything (default)\n * const strictEdit = createEditTool({ \"*\": \"ask\" })\n *\n * @example\n * // Allow all edits without approval\n * const permissiveEdit = createEditTool(\"allow\")\n */\nexport function createEditTool(\n\tpermissions: Permission | Record<string, Permission> = \"ask\",\n) {\n\tconst permissionPatterns =\n\t\ttypeof permissions === \"string\" ? { \"*\": permissions } : permissions\n\n\treturn tool({\n\t\tdescription,\n\t\tinputSchema,\n\t\toutputSchema,\n\t\tneedsApproval: ({ filePath }) => {\n\t\t\tconst filepath = path.isAbsolute(filePath)\n\t\t\t\t? filePath\n\t\t\t\t: path.join(process.cwd(), filePath)\n\n\t\t\tconst permission = checkPermission(filepath, permissionPatterns)\n\n\t\t\tif (permission === \"deny\") {\n\t\t\t\tthrow new PermissionDeniedError(\"edit\", filepath)\n\t\t\t}\n\n\t\t\t// Return true if approval needed (ask), false if auto-allowed\n\t\t\treturn permission === \"ask\"\n\t\t},\n\t\ttoModelOutput: (output) => {\n\t\t\tif (output.status === \"error\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"error-text\",\n\t\t\t\t\tvalue: `Error editing ${output.filePath}: ${output.error}`,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output.status === \"success\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"text\",\n\t\t\t\t\tvalue: `${output.result}\\n\\nChanges:\\n${output.diff}`,\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t\t},\n\t\tasync *execute({ filePath, oldString, newString, replaceAll = false }) {\n\t\t\tif (oldString === newString) {\n\t\t\t\tthrow new Error(\"oldString and newString must be different\")\n\t\t\t}\n\n\t\t\tconst filepath = path.isAbsolute(filePath)\n\t\t\t\t? filePath\n\t\t\t\t: path.join(process.cwd(), filePath)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"pending\",\n\t\t\t\tmessage: `Editing file: ${filepath}`,\n\t\t\t\tfilePath: filepath,\n\t\t\t\tresult: undefined,\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tawait fs.access(filepath)\n\t\t\t\t} catch {\n\t\t\t\t\tthrow new Error(`File ${filepath} not found`)\n\t\t\t\t}\n\n\t\t\t\tconst stats = await fs.stat(filepath)\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tthrow new Error(`Path is a directory, not a file: ${filepath}`)\n\t\t\t\t}\n\n\t\t\t\tconst contentRaw = await fs.readFile(filepath, \"utf-8\")\n\t\t\t\tconst content = normalizeLineEndings(contentRaw)\n\n\t\t\t\t// Handle empty oldString as creating/overwriting file\n\t\t\t\tif (oldString === \"\") {\n\t\t\t\t\tawait fs.writeFile(filepath, newString, \"utf-8\")\n\t\t\t\t\tconst diff = trimDiff(\n\t\t\t\t\t\tcreateTwoFilesPatch(filepath, filepath, content, newString),\n\t\t\t\t\t)\n\t\t\t\t\tyield {\n\t\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\t\tmessage: `File created: ${filepath}`,\n\t\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\t\tresult: `File created: ${filepath}`,\n\t\t\t\t\t\tdiff,\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Use the replace function with all strategies\n\t\t\t\tconst result = replace(content, oldString, newString, replaceAll)\n\n\t\t\t\tawait fs.writeFile(filepath, result, \"utf-8\")\n\n\t\t\t\tconst message = `File edited: ${filepath}`\n\t\t\t\tconst diff = trimDiff(\n\t\t\t\t\tcreateTwoFilesPatch(filepath, filepath, content, result),\n\t\t\t\t)\n\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\tmessage,\n\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\tresult: message,\n\t\t\t\t\tdiff,\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: `Failed to edit ${filepath}`,\n\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n}\n\n/**\n * Default edit tool with standard permissions.\n * All file edits require approval by default.\n */\nexport const editTool = createEditTool()\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		},
		{
			"path": "tools/lib/trim-diff.ts",
			"type": "registry:lib",
			"content": "/**\n * Trim common indentation from diff output for cleaner display.\n * Removes the minimum shared indentation from all diff content lines.\n */\nexport function trimDiff(diff: string): string {\n\tconst lines = diff.split(\"\\n\")\n\tconst contentLines = lines.filter(\n\t\t(line) =>\n\t\t\t(line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) &&\n\t\t\t!line.startsWith(\"---\") &&\n\t\t\t!line.startsWith(\"+++\"),\n\t)\n\n\tif (contentLines.length === 0) return diff\n\n\tlet min = Infinity\n\tfor (const line of contentLines) {\n\t\tconst content = line.slice(1)\n\t\tif (content.trim().length > 0) {\n\t\t\tconst match = content.match(/^(\\s*)/)\n\t\t\tif (match) min = Math.min(min, match[1]!.length)\n\t\t}\n\t}\n\n\tif (min === Infinity || min === 0) return diff\n\n\tconst trimmedLines = lines.map((line) => {\n\t\tif (\n\t\t\t(line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) &&\n\t\t\t!line.startsWith(\"---\") &&\n\t\t\t!line.startsWith(\"+++\")\n\t\t) {\n\t\t\tconst prefix = line[0]\n\t\t\tconst content = line.slice(1)\n\t\t\treturn prefix + content.slice(min)\n\t\t}\n\t\treturn line\n\t})\n\n\treturn trimmedLines.join(\"\\n\")\n}\n"
		}
	]
}
