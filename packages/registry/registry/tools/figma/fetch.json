{
	"name": "figma/fetch",
	"type": "registry:tool",
	"title": "Fetch",
	"description": "Fetch a Figma file and initialize the migration.",
	"dependencies": ["ai@beta", "zod"],
	"files": [
		{
			"path": "tools/figma/fetch.ts",
			"type": "registry:tool",
			"content": "import { promises as fs } from \"node:fs\"\nimport * as path from \"node:path\"\nimport { tool } from \"ai\"\nimport { z } from \"zod\"\nimport { extractFigmaStructure } from \"./lib/parser\"\nimport type {\n\tComponentState,\n\tExtractedData,\n\tFigmaFile,\n\tMigrationState,\n\tPageState,\n} from \"./lib/types\"\n\nconst FIGMA_API_BASE = \"https://api.figma.com/v1\"\nconst MIGRATION_FILE = \".figma-migration.json\"\n\nlet currentProjectDir: string | null = null\n\nexport function setProjectDir(dir: string): void {\n\tcurrentProjectDir = dir\n}\n\nexport function getProjectDir(): string {\n\treturn currentProjectDir || process.cwd()\n}\n\nfunction parseFileKeyFromUrl(urlOrKey: string): string {\n\tif (!urlOrKey.includes(\"/\")) {\n\t\treturn urlOrKey\n\t}\n\n\tconst patterns = [\n\t\t/figma\\.com\\/file\\/([a-zA-Z0-9]+)/,\n\t\t/figma\\.com\\/design\\/([a-zA-Z0-9]+)/,\n\t]\n\n\tfor (const pattern of patterns) {\n\t\tconst match = urlOrKey.match(pattern)\n\t\tif (match?.[1]) {\n\t\t\treturn match[1]\n\t\t}\n\t}\n\n\treturn urlOrKey\n}\n\nasync function fetchFigmaFile(\n\tfileKey: string,\n\ttoken: string,\n): Promise<FigmaFile> {\n\tconst response = await fetch(`${FIGMA_API_BASE}/files/${fileKey}`, {\n\t\theaders: {\n\t\t\t\"X-Figma-Token\": token,\n\t\t},\n\t})\n\n\tif (!response.ok) {\n\t\tconst errorText = await response.text()\n\t\tthrow new Error(\n\t\t\t`Figma API error (${response.status}): ${errorText || response.statusText}`,\n\t\t)\n\t}\n\n\treturn response.json() as Promise<FigmaFile>\n}\n\nfunction buildComponentDependencies(\n\tdata: ExtractedData,\n): Map<string, Set<string>> {\n\tconst deps = new Map<string, Set<string>>()\n\n\tfor (const [compId, compData] of Object.entries(data.components)) {\n\t\tconst compDeps = new Set<string>()\n\t\tif (compData.definition?.children) {\n\t\t\tfindInstanceDependencies(compData.definition.children, compDeps, compId)\n\t\t}\n\t\tdeps.set(compId, compDeps)\n\t}\n\n\treturn deps\n}\n\nfunction findInstanceDependencies(\n\tnodes: ExtractedData[\"components\"][string][\"definition\"][],\n\tdeps: Set<string>,\n\tselfId: string,\n): void {\n\tfor (const node of nodes) {\n\t\tif (!node) continue\n\t\tif (\n\t\t\tnode.type === \"INSTANCE\" &&\n\t\t\tnode.componentId &&\n\t\t\tnode.componentId !== selfId\n\t\t) {\n\t\t\tdeps.add(node.componentId)\n\t\t}\n\t\tif (node.children) {\n\t\t\tfindInstanceDependencies(node.children, deps, selfId)\n\t\t}\n\t}\n}\n\nfunction createMigrationState(\n\tdata: ExtractedData,\n\tfileKey: string,\n\tfileUrl: string,\n): MigrationState {\n\tconst componentDeps = buildComponentDependencies(data)\n\n\tconst components: Record<string, ComponentState> = {}\n\tfor (const [compId, compData] of Object.entries(data.components)) {\n\t\tconst deps = Array.from(componentDeps.get(compId) || [])\n\t\tcomponents[compId] = {\n\t\t\tfigmaId: compId,\n\t\t\tname: compData.name,\n\t\t\tstatus: \"pending\",\n\t\t\tdependencies: deps,\n\t\t\tdependenciesReady: deps.length === 0,\n\t\t\tinstanceCount: compData.instanceCount,\n\t\t}\n\t}\n\n\tconst pages: Record<string, PageState> = {}\n\tfor (const [frameId, frameData] of Object.entries(data.frames)) {\n\t\tpages[frameId] = {\n\t\t\tfigmaId: frameId,\n\t\t\tframeName: frameData.name,\n\t\t\tstatus: \"blocked\",\n\t\t\tcomponentsUsed: frameData.componentsUsed,\n\t\t\tcomponentsReady: false,\n\t\t}\n\t}\n\n\t// Update dependency readiness\n\tconst doneOrSkipped = new Set<string>()\n\tfor (const comp of Object.values(components)) {\n\t\tcomp.dependenciesReady =\n\t\t\tcomp.dependencies.length === 0 ||\n\t\t\tcomp.dependencies.every((dep) => doneOrSkipped.has(dep))\n\t}\n\tfor (const page of Object.values(pages)) {\n\t\tpage.componentsReady = page.componentsUsed.every((compId) =>\n\t\t\tdoneOrSkipped.has(compId),\n\t\t)\n\t\tif (page.status === \"blocked\" && page.componentsReady) {\n\t\t\tpage.status = \"pending\"\n\t\t}\n\t}\n\n\treturn {\n\t\tfigmaFileKey: fileKey,\n\t\tfigmaFileUrl: fileUrl,\n\t\tcreatedAt: new Date().toISOString(),\n\t\tupdatedAt: new Date().toISOString(),\n\t\tstats: {\n\t\t\ttotalComponents: Object.keys(components).length,\n\t\t\tcompletedComponents: 0,\n\t\t\tskippedComponents: 0,\n\t\t\ttotalPages: Object.keys(pages).length,\n\t\t\tcompletedPages: 0,\n\t\t\tphase: \"components\",\n\t\t},\n\t\tcomponents,\n\t\tpages,\n\t\tfigmaData: data,\n\t}\n}\n\nconst description = `Fetch a Figma file and initialize the migration.\n\nThis tool:\n1. Fetches the Figma file from the Figma REST API\n2. Extracts and processes all components and frames\n3. Creates the migration state file (.figma-migration.json)\n4. Returns the components ready to be migrated\n\nInput can be either:\n- A Figma file key (e.g., \"abc123XYZ\")\n- A full Figma URL (e.g., \"https://www.figma.com/file/abc123XYZ/My-Design\")\n\nAfter this, use migrationStart to begin working on components.`\n\nexport function createFigmaFetchTool(figmaToken?: string) {\n\treturn tool({\n\t\tdescription,\n\t\tinputSchema: z.object({\n\t\t\tfileKeyOrUrl: z\n\t\t\t\t.string()\n\t\t\t\t.describe(\"The Figma file key or full URL to fetch\"),\n\t\t\tskipInvisible: z\n\t\t\t\t.boolean()\n\t\t\t\t.default(true)\n\t\t\t\t.describe(\"Skip invisible nodes in the design\"),\n\t\t}),\n\t\toutputSchema: z.union([\n\t\t\tz.object({\n\t\t\t\tstatus: z.literal(\"pending\"),\n\t\t\t\tmessage: z.string(),\n\t\t\t}),\n\t\t\tz.object({\n\t\t\t\tstatus: z.literal(\"success\"),\n\t\t\t\tmessage: z.string(),\n\t\t\t\tfileKey: z.string(),\n\t\t\t\ttotalComponents: z.number(),\n\t\t\t\ttotalPages: z.number(),\n\t\t\t\treadyComponents: z.array(\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tid: z.string(),\n\t\t\t\t\t\tname: z.string(),\n\t\t\t\t\t\tinstanceCount: z.number(),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t\tz.object({\n\t\t\t\tstatus: z.literal(\"error\"),\n\t\t\t\tmessage: z.string(),\n\t\t\t\terror: z.string(),\n\t\t\t}),\n\t\t]),\n\t\ttoModelOutput: (output) => {\n\t\t\tif (output.status === \"error\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"error-text\",\n\t\t\t\t\tvalue: output.error,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output.status === \"pending\") {\n\t\t\t\treturn { type: \"text\", value: output.message }\n\t\t\t}\n\n\t\t\tconst readyList = output.readyComponents\n\t\t\t\t.slice(0, 10)\n\t\t\t\t.map((c) => `  - ${c.name} (id: ${c.id}, ${c.instanceCount}x)`)\n\t\t\t\t.join(\"\\n\")\n\n\t\t\treturn {\n\t\t\t\ttype: \"text\",\n\t\t\t\tvalue: `Migration initialized for ${output.fileKey}\n\n${output.totalComponents} components, ${output.totalPages} pages\n\nReady to start (${output.readyComponents.length} components with no dependencies):\n${readyList}${output.readyComponents.length > 10 ? `\\n  ... and ${output.readyComponents.length - 10} more` : \"\"}\n\nUse migrationStart with a component id to begin.`,\n\t\t\t}\n\t\t},\n\t\tasync *execute({ fileKeyOrUrl, skipInvisible }) {\n\t\t\tconst token = figmaToken || process.env.FIGMA_TOKEN\n\n\t\t\tif (!token) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"No Figma token provided\",\n\t\t\t\t\terror:\n\t\t\t\t\t\t\"FIGMA_TOKEN environment variable is not set. Please set it to your Figma personal access token.\",\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst fileKey = parseFileKeyFromUrl(fileKeyOrUrl)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"pending\",\n\t\t\t\tmessage: `Fetching Figma file ${fileKey}...`,\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst fileData = await fetchFigmaFile(fileKey, token)\n\t\t\t\tconst extracted = extractFigmaStructure(fileData, { skipInvisible })\n\n\t\t\t\t// Create migration state and save to disk\n\t\t\t\tconst state = createMigrationState(extracted, fileKey, fileKeyOrUrl)\n\t\t\t\tconst filepath = path.join(getProjectDir(), MIGRATION_FILE)\n\t\t\t\tawait fs.writeFile(filepath, JSON.stringify(state, null, 2))\n\n\t\t\t\t// Find ready components (no dependencies)\n\t\t\t\tconst readyComponents = Object.values(state.components)\n\t\t\t\t\t.filter((c) => c.status === \"pending\" && c.dependenciesReady)\n\t\t\t\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n\t\t\t\t\t.map((c) => ({\n\t\t\t\t\t\tid: c.figmaId,\n\t\t\t\t\t\tname: c.name,\n\t\t\t\t\t\tinstanceCount: c.instanceCount,\n\t\t\t\t\t}))\n\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\tmessage: \"Migration initialized\",\n\t\t\t\t\tfileKey,\n\t\t\t\t\ttotalComponents: state.stats.totalComponents,\n\t\t\t\t\ttotalPages: state.stats.totalPages,\n\t\t\t\t\treadyComponents,\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Failed to fetch Figma file\",\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n}\n"
		},
		{
			"path": "tools/figma/lib/parser.ts",
			"type": "registry:lib",
			"content": "import type {\n\tComponentData,\n\tExtractedData,\n\tExtractionConfig,\n\tFigmaFile,\n\tFigmaNode,\n\tFrameInfo,\n\tPageInfo,\n\tSectionInfo,\n} from \"./types\"\n\nconst defaultConfig: Required<ExtractionConfig> = {\n\tskipInvisible: true,\n}\n\ninterface TraversalContext {\n\tpageId: string\n\tframeId: string\n}\n\nfunction isFrameType(type: string): boolean {\n\treturn type === \"FRAME\" || type === \"COMPONENT\" || type === \"COMPONENT_SET\"\n}\n\nexport function extractFigmaStructure(\n\tfileData: FigmaFile,\n\tconfig: ExtractionConfig = {},\n): ExtractedData {\n\tconst { skipInvisible } = { ...defaultConfig, ...config }\n\n\tconst shouldSkipNode = (node: FigmaNode): boolean => {\n\t\tif (skipInvisible && node.visible === false) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tconst filterInvisibleNodes = (node: FigmaNode): FigmaNode => {\n\t\tif (!skipInvisible) return node\n\n\t\tconst filtered = { ...node }\n\t\tif (filtered.children) {\n\t\t\tfiltered.children = filtered.children\n\t\t\t\t.filter((child) => child.visible !== false)\n\t\t\t\t.map((child) => filterInvisibleNodes(child))\n\t\t}\n\t\treturn filtered\n\t}\n\n\tconst componentUsage = new Map<\n\t\tstring,\n\t\t{\n\t\t\tusedInFrames: Set<string>\n\t\t\tinstanceCount: number\n\t\t}\n\t>()\n\n\tconst pages: PageInfo[] = []\n\tconst allSections = new Map<string, SectionInfo>()\n\tconst allFrames = new Map<string, FrameInfo>()\n\tconst componentDefinitions = new Map<string, FigmaNode>()\n\tconst frameComponents = new Map<string, Set<string>>()\n\n\tconst getComponentName = (id: string): string => {\n\t\treturn fileData.components[id]?.name || \"Unknown Component\"\n\t}\n\n\tconst getComponentDescription = (id: string): string | undefined => {\n\t\treturn fileData.components[id]?.description\n\t}\n\n\tconst cloneNode = (node: FigmaNode): FigmaNode => {\n\t\treturn JSON.parse(JSON.stringify(node))\n\t}\n\n\tfunction collectSections(\n\t\tnode: FigmaNode,\n\t\tparentSectionId?: string,\n\t): string[] {\n\t\tconst sectionIds: string[] = []\n\n\t\tif (!node.children) return sectionIds\n\n\t\tfor (const child of node.children) {\n\t\t\tif (shouldSkipNode(child)) continue\n\n\t\t\tif (child.type === \"SECTION\") {\n\t\t\t\tconst sectionInfo: SectionInfo = {\n\t\t\t\t\tid: child.id,\n\t\t\t\t\tname: child.name,\n\t\t\t\t\tparentSectionId,\n\t\t\t\t\tframeIds: [],\n\t\t\t\t}\n\n\t\t\t\tif (child.children) {\n\t\t\t\t\tfor (const grandChild of child.children) {\n\t\t\t\t\t\tif (!shouldSkipNode(grandChild) && isFrameType(grandChild.type)) {\n\t\t\t\t\t\t\tsectionInfo.frameIds.push(grandChild.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tallSections.set(child.id, sectionInfo)\n\t\t\t\tsectionIds.push(child.id)\n\n\t\t\t\tconst nestedSectionIds = collectSections(child, child.id)\n\t\t\t\tsectionIds.push(...nestedSectionIds)\n\t\t\t}\n\t\t}\n\n\t\treturn sectionIds\n\t}\n\n\tfunction traverseFrame(node: FigmaNode, context: TraversalContext) {\n\t\tif (shouldSkipNode(node)) return\n\n\t\tif (node.type === \"COMPONENT\") {\n\t\t\tcomponentDefinitions.set(node.id, filterInvisibleNodes(cloneNode(node)))\n\t\t}\n\n\t\tif (node.type === \"COMPONENT_SET\") {\n\t\t\tcomponentDefinitions.set(node.id, filterInvisibleNodes(cloneNode(node)))\n\t\t\tif (node.children) {\n\t\t\t\tfor (const variant of node.children) {\n\t\t\t\t\tif (variant.type === \"COMPONENT\" && !shouldSkipNode(variant)) {\n\t\t\t\t\t\tcomponentDefinitions.set(\n\t\t\t\t\t\t\tvariant.id,\n\t\t\t\t\t\t\tfilterInvisibleNodes(cloneNode(variant)),\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (node.type === \"INSTANCE\" && node.componentId) {\n\t\t\tconst compId = node.componentId\n\n\t\t\tframeComponents.get(context.frameId)?.add(compId)\n\n\t\t\tconst existing = componentUsage.get(compId)\n\t\t\tif (existing) {\n\t\t\t\texisting.instanceCount++\n\t\t\t\texisting.usedInFrames.add(context.frameId)\n\t\t\t} else {\n\t\t\t\tcomponentUsage.set(compId, {\n\t\t\t\t\tinstanceCount: 1,\n\t\t\t\t\tusedInFrames: new Set([context.frameId]),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tif (node.children) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\ttraverseFrame(child, context)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction collectFrames(\n\t\tnode: FigmaNode,\n\t\tpageId: string,\n\t\tsectionId?: string,\n\t): FrameInfo[] {\n\t\tconst frames: FrameInfo[] = []\n\n\t\tif (!node.children) return frames\n\n\t\tfor (const child of node.children) {\n\t\t\tif (shouldSkipNode(child)) continue\n\n\t\t\tif (child.type === \"SECTION\") {\n\t\t\t\tconst sectionFrames = collectFrames(child, pageId, child.id)\n\t\t\t\tframes.push(...sectionFrames)\n\t\t\t} else if (isFrameType(child.type)) {\n\t\t\t\tframeComponents.set(child.id, new Set())\n\n\t\t\t\ttraverseFrame(child, {\n\t\t\t\t\tpageId,\n\t\t\t\t\tframeId: child.id,\n\t\t\t\t})\n\n\t\t\t\tconst frameInfo: FrameInfo = {\n\t\t\t\t\tid: child.id,\n\t\t\t\t\tname: child.name,\n\t\t\t\t\ttype: child.type,\n\t\t\t\t\tpageId,\n\t\t\t\t\tsectionId,\n\t\t\t\t\tcomponentsUsed: Array.from(frameComponents.get(child.id) || []),\n\t\t\t\t\tdefinition: filterInvisibleNodes(cloneNode(child)),\n\t\t\t\t}\n\n\t\t\t\tframes.push(frameInfo)\n\t\t\t\tallFrames.set(child.id, frameInfo)\n\t\t\t}\n\t\t}\n\n\t\treturn frames\n\t}\n\n\tif (fileData.document.children) {\n\t\tfor (const pageNode of fileData.document.children) {\n\t\t\tif (pageNode.type === \"CANVAS\") {\n\t\t\t\tconst pageId = pageNode.id\n\t\t\t\tconst pageName = pageNode.name\n\n\t\t\t\tconst sectionIds = collectSections(pageNode)\n\t\t\t\tconst frames = collectFrames(pageNode, pageId)\n\n\t\t\t\tpages.push({\n\t\t\t\t\tid: pageId,\n\t\t\t\t\tname: pageName,\n\t\t\t\t\tsectionIds,\n\t\t\t\t\tframeIds: frames.map((f) => f.id),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tconst components: Record<string, ComponentData> = {}\n\n\tfor (const [compId, usage] of componentUsage.entries()) {\n\t\tcomponents[compId] = {\n\t\t\tname: getComponentName(compId),\n\t\t\tdescription: getComponentDescription(compId),\n\t\t\tdefinition: componentDefinitions.get(compId) || null,\n\t\t\tusedInFrames: Array.from(usage.usedInFrames),\n\t\t\tinstanceCount: usage.instanceCount,\n\t\t}\n\t}\n\n\treturn {\n\t\tpages,\n\t\tsections: Object.fromEntries(allSections),\n\t\tframes: Object.fromEntries(allFrames),\n\t\tcomponents,\n\t}\n}\n\nexport function getComponent(\n\tdata: ExtractedData,\n\tnameOrId: string,\n): ComponentData | null {\n\tif (data.components[nameOrId]) {\n\t\treturn data.components[nameOrId]\n\t}\n\n\tconst lowerName = nameOrId.toLowerCase()\n\tfor (const comp of Object.values(data.components)) {\n\t\tif (comp.name.toLowerCase() === lowerName) {\n\t\t\treturn comp\n\t\t}\n\t}\n\n\treturn null\n}\n\nexport function listComponents(\n\tdata: ExtractedData,\n): { id: string; name: string; instanceCount: number }[] {\n\treturn Object.entries(data.components)\n\t\t.map(([id, comp]) => ({\n\t\t\tid,\n\t\t\tname: comp.name,\n\t\t\tinstanceCount: comp.instanceCount,\n\t\t}))\n\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n}\n\nexport function listFrames(data: ExtractedData): FrameInfo[] {\n\treturn Object.values(data.frames)\n}\n\nexport function getFrame(\n\tdata: ExtractedData,\n\tnameOrId: string,\n): FrameInfo | null {\n\tif (data.frames[nameOrId]) {\n\t\treturn data.frames[nameOrId]\n\t}\n\n\tconst lowerName = nameOrId.toLowerCase()\n\tfor (const frame of Object.values(data.frames)) {\n\t\tif (frame.name.toLowerCase() === lowerName) {\n\t\t\treturn frame\n\t\t}\n\t}\n\n\treturn null\n}\n"
		},
		{
			"path": "tools/figma/lib/types.ts",
			"type": "registry:lib",
			"content": "// ============================================================================\n// Figma Node Types & Interfaces\n// Based on https://developers.figma.com/docs/rest-api/file-node-types/\n// ============================================================================\n\nexport interface Color {\n\tr: number\n\tg: number\n\tb: number\n\ta: number\n}\n\nexport interface Paint {\n\ttype:\n\t\t| \"SOLID\"\n\t\t| \"GRADIENT_LINEAR\"\n\t\t| \"GRADIENT_RADIAL\"\n\t\t| \"GRADIENT_ANGULAR\"\n\t\t| \"GRADIENT_DIAMOND\"\n\t\t| \"IMAGE\"\n\t\t| \"EMOJI\"\n\t\t| \"VIDEO\"\n\tvisible?: boolean\n\topacity?: number\n\tcolor?: Color\n\tblendMode?: string\n\tgradientHandlePositions?: { x: number; y: number }[]\n\tgradientStops?: { position: number; color: Color }[]\n\tscaleMode?: string\n\timageRef?: string\n}\n\nexport interface Effect {\n\ttype: \"INNER_SHADOW\" | \"DROP_SHADOW\" | \"LAYER_BLUR\" | \"BACKGROUND_BLUR\"\n\tvisible?: boolean\n\tradius: number\n\tcolor?: Color\n\tblendMode?: string\n\toffset?: { x: number; y: number }\n\tspread?: number\n}\n\nexport interface Constraint {\n\ttype: \"MIN\" | \"CENTER\" | \"MAX\" | \"STRETCH\" | \"SCALE\"\n\tvalue: number\n}\n\nexport interface Rectangle {\n\tx: number\n\ty: number\n\twidth: number\n\theight: number\n}\n\nexport interface TypeStyle {\n\tfontFamily?: string\n\tfontPostScriptName?: string\n\tfontWeight?: number\n\tfontSize?: number\n\ttextAlignHorizontal?: \"LEFT\" | \"RIGHT\" | \"CENTER\" | \"JUSTIFIED\"\n\ttextAlignVertical?: \"TOP\" | \"CENTER\" | \"BOTTOM\"\n\tletterSpacing?: number\n\tlineHeightPx?: number\n\tlineHeightPercent?: number\n\tlineHeightUnit?: string\n\ttextCase?: \"ORIGINAL\" | \"UPPER\" | \"LOWER\" | \"TITLE\"\n\ttextDecoration?: \"NONE\" | \"STRIKETHROUGH\" | \"UNDERLINE\"\n\tfills?: Paint[]\n}\n\nexport interface StrokeWeights {\n\ttop: number\n\tright: number\n\tbottom: number\n\tleft: number\n}\n\nexport interface FigmaNode {\n\tid: string\n\tname: string\n\ttype: string\n\tvisible?: boolean\n\tchildren?: FigmaNode[]\n\n\t// Instance-specific\n\tcomponentId?: string\n\n\t// Component-specific\n\tcomponentPropertyDefinitions?: Record<string, unknown>\n\n\t// Geometry\n\tabsoluteBoundingBox?: Rectangle\n\tabsoluteRenderBounds?: Rectangle\n\tsize?: { x: number; y: number }\n\trelativeTransform?: number[][]\n\n\t// Constraints & Layout\n\tconstraints?: { horizontal: string; vertical: string }\n\tlayoutAlign?: string\n\tlayoutGrow?: number\n\tlayoutPositioning?: string\n\n\t// Auto Layout (Flexbox)\n\tlayoutMode?: \"NONE\" | \"HORIZONTAL\" | \"VERTICAL\"\n\tprimaryAxisSizingMode?: \"FIXED\" | \"AUTO\"\n\tcounterAxisSizingMode?: \"FIXED\" | \"AUTO\"\n\tprimaryAxisAlignItems?: \"MIN\" | \"CENTER\" | \"MAX\" | \"SPACE_BETWEEN\"\n\tcounterAxisAlignItems?: \"MIN\" | \"CENTER\" | \"MAX\" | \"BASELINE\"\n\tpaddingLeft?: number\n\tpaddingRight?: number\n\tpaddingTop?: number\n\tpaddingBottom?: number\n\titemSpacing?: number\n\tcounterAxisSpacing?: number\n\tlayoutWrap?: \"NO_WRAP\" | \"WRAP\"\n\n\t// Appearance\n\tfills?: Paint[]\n\tstrokes?: Paint[]\n\tstrokeWeight?: number\n\tstrokeAlign?: \"INSIDE\" | \"OUTSIDE\" | \"CENTER\"\n\tstrokeCap?: string\n\tstrokeJoin?: string\n\tstrokeDashes?: number[]\n\tindividualStrokeWeights?: StrokeWeights\n\tcornerRadius?: number\n\trectangleCornerRadii?: number[]\n\teffects?: Effect[]\n\tblendMode?: string\n\topacity?: number\n\tisMask?: boolean\n\n\t// Clipping\n\tclipsContent?: boolean\n\n\t// Text-specific\n\tcharacters?: string\n\tstyle?: TypeStyle\n\tcharacterStyleOverrides?: number[]\n\tstyleOverrideTable?: Record<string, TypeStyle>\n\ttextAutoResize?: string\n\n\t// Vector-specific\n\tfillGeometry?: unknown[]\n\tstrokeGeometry?: unknown[]\n\n\t// Export settings\n\texportSettings?: unknown[]\n\n\t// Interactions/Prototyping\n\ttransitionNodeID?: string\n\ttransitionDuration?: number\n\ttransitionEasing?: string\n}\n\nexport interface FigmaFile {\n\tdocument: FigmaNode\n\tcomponents: Record<\n\t\tstring,\n\t\t{ name: string; description?: string; key?: string }\n\t>\n\tstyles?: Record<\n\t\tstring,\n\t\t{ name: string; styleType: string; description?: string }\n\t>\n}\n\n// ============================================================================\n// Extracted Data Types\n// ============================================================================\n\nexport interface FrameInfo {\n\tid: string\n\tname: string\n\ttype: string\n\tpageId: string\n\tsectionId?: string\n\tcomponentsUsed: string[]\n\tdefinition: FigmaNode | null\n}\n\nexport interface SectionInfo {\n\tid: string\n\tname: string\n\tparentSectionId?: string\n\tframeIds: string[]\n}\n\nexport interface PageInfo {\n\tid: string\n\tname: string\n\tsectionIds: string[]\n\tframeIds: string[]\n}\n\nexport interface ComponentData {\n\tname: string\n\tdescription?: string\n\tdefinition: FigmaNode | null\n\tusedInFrames: string[]\n\tinstanceCount: number\n}\n\nexport interface ExtractedData {\n\tpages: PageInfo[]\n\tsections: Record<string, SectionInfo>\n\tframes: Record<string, FrameInfo>\n\tcomponents: Record<string, ComponentData>\n}\n\nexport interface ExtractionConfig {\n\tskipInvisible?: boolean\n}\n\n// ============================================================================\n// Migration State Types\n// ============================================================================\n\nexport type MigrationPhase = \"components\" | \"pages\" | \"done\"\n\nexport type ComponentStatus = \"pending\" | \"in_progress\" | \"done\" | \"skipped\"\n\nexport type PageStatus = \"blocked\" | \"pending\" | \"in_progress\" | \"done\"\n\nexport interface ComponentState {\n\tfigmaId: string\n\tname: string\n\tstatus: ComponentStatus\n\tdependencies: string[]\n\tdependenciesReady: boolean\n\tinstanceCount: number\n\toutputPath?: string\n\tcompletedAt?: string\n\tskipReason?: string\n}\n\nexport interface PageState {\n\tfigmaId: string\n\tframeName: string\n\tstatus: PageStatus\n\tcomponentsUsed: string[]\n\tcomponentsReady: boolean\n\toutputPath?: string\n\tcompletedAt?: string\n}\n\nexport interface MigrationStats {\n\ttotalComponents: number\n\tcompletedComponents: number\n\tskippedComponents: number\n\ttotalPages: number\n\tcompletedPages: number\n\tphase: MigrationPhase\n}\n\nexport interface MigrationState {\n\tfigmaFileKey: string\n\tfigmaFileUrl: string\n\tcreatedAt: string\n\tupdatedAt: string\n\tstats: MigrationStats\n\tcomponents: Record<string, ComponentState>\n\tpages: Record<string, PageState>\n\t/** Post-processed Figma data for component/page definitions */\n\tfigmaData: ExtractedData\n}\n\n// ============================================================================\n// Tool Input/Output Types\n// ============================================================================\n\nexport interface MigrationNextItem {\n\ttype: \"component\" | \"page\"\n\tid: string\n\tname: string\n\tinstanceCount?: number\n\tdependencies?: string[]\n\tcomponentsUsed?: string[]\n}\n\nexport interface MigrationProgressResult {\n\tphase: MigrationPhase\n\tcomponents: {\n\t\ttotal: number\n\t\tdone: number\n\t\tinProgress: number\n\t\tpending: number\n\t\tskipped: number\n\t}\n\tpages: {\n\t\ttotal: number\n\t\tdone: number\n\t\tready: number\n\t\tblocked: number\n\t}\n\tcurrentTask?: string\n\tnextUp: string[]\n}\n"
		}
	]
}
