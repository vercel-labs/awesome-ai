{
	"name": "figma/migration-state",
	"type": "registry:tool",
	"title": "Migration State",
	"description": "Migration State tool for AI agents",
	"dependencies": ["ai@beta", "zod"],
	"files": [
		{
			"path": "tools/figma/migration-state.ts",
			"type": "registry:tool",
			"content": "import { promises as fs } from \"node:fs\"\nimport * as path from \"node:path\"\nimport { tool } from \"ai\"\nimport { z } from \"zod\"\nimport { getProjectDir } from \"./fetch\"\nimport type {\n\tMigrationNextItem,\n\tMigrationPhase,\n\tMigrationProgressResult,\n\tMigrationState,\n\tMigrationStats,\n} from \"./lib/types\"\n\nconst MIGRATION_FILE = \".figma-migration.json\"\n\nasync function readMigrationState(\n\tprojectDir?: string,\n): Promise<MigrationState | null> {\n\tconst cwd = projectDir || getProjectDir()\n\ttry {\n\t\tconst filepath = path.join(cwd, MIGRATION_FILE)\n\t\tconst content = await fs.readFile(filepath, \"utf-8\")\n\t\treturn JSON.parse(content)\n\t} catch {\n\t\treturn null\n\t}\n}\n\nasync function writeMigrationState(\n\tstate: MigrationState,\n\tprojectDir?: string,\n): Promise<void> {\n\tconst cwd = projectDir || getProjectDir()\n\tconst filepath = path.join(cwd, MIGRATION_FILE)\n\tstate.updatedAt = new Date().toISOString()\n\tawait fs.writeFile(filepath, JSON.stringify(state, null, 2))\n}\n\nfunction computeStats(state: MigrationState): MigrationStats {\n\tconst components = Object.values(state.components)\n\tconst pages = Object.values(state.pages)\n\n\tconst completedComponents = components.filter(\n\t\t(c) => c.status === \"done\",\n\t).length\n\tconst skippedComponents = components.filter(\n\t\t(c) => c.status === \"skipped\",\n\t).length\n\tconst completedPages = pages.filter((p) => p.status === \"done\").length\n\n\tconst allComponentsDone =\n\t\tcompletedComponents + skippedComponents === components.length\n\tconst allPagesDone = completedPages === pages.length\n\n\tlet phase: MigrationPhase = \"components\"\n\tif (allComponentsDone && !allPagesDone) {\n\t\tphase = \"pages\"\n\t} else if (allComponentsDone && allPagesDone) {\n\t\tphase = \"done\"\n\t}\n\n\treturn {\n\t\ttotalComponents: components.length,\n\t\tcompletedComponents,\n\t\tskippedComponents,\n\t\ttotalPages: pages.length,\n\t\tcompletedPages,\n\t\tphase,\n\t}\n}\n\nfunction updateDependencyReadiness(state: MigrationState): void {\n\tconst doneOrSkipped = new Set(\n\t\tObject.values(state.components)\n\t\t\t.filter((c) => c.status === \"done\" || c.status === \"skipped\")\n\t\t\t.map((c) => c.figmaId),\n\t)\n\n\tfor (const comp of Object.values(state.components)) {\n\t\tcomp.dependenciesReady =\n\t\t\tcomp.dependencies.length === 0 ||\n\t\t\tcomp.dependencies.every((dep) => doneOrSkipped.has(dep))\n\t}\n\n\tfor (const page of Object.values(state.pages)) {\n\t\tpage.componentsReady = page.componentsUsed.every((compId) =>\n\t\t\tdoneOrSkipped.has(compId),\n\t\t)\n\t\tif (page.status === \"blocked\" && page.componentsReady) {\n\t\t\tpage.status = \"pending\"\n\t\t}\n\t}\n}\n\n// ============================================================================\n// Tool: migrationProgress\n// ============================================================================\n\nconst progressDescription = `Get the current migration progress.\n\nReturns:\n- Current phase (components or pages)\n- Counts for completed, in-progress, and pending items\n- Current task being worked on (if any)\n- Next items that will be ready\n\nUse this to check overall progress.`\n\nexport const migrationProgress = tool({\n\tdescription: progressDescription,\n\tinputSchema: z.object({}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tprogress: z.object({\n\t\t\t\tphase: z.string(),\n\t\t\t\tcomponents: z.object({\n\t\t\t\t\ttotal: z.number(),\n\t\t\t\t\tdone: z.number(),\n\t\t\t\t\tinProgress: z.number(),\n\t\t\t\t\tpending: z.number(),\n\t\t\t\t\tskipped: z.number(),\n\t\t\t\t}),\n\t\t\t\tpages: z.object({\n\t\t\t\t\ttotal: z.number(),\n\t\t\t\t\tdone: z.number(),\n\t\t\t\t\tready: z.number(),\n\t\t\t\t\tblocked: z.number(),\n\t\t\t\t}),\n\t\t\t\tcurrentTask: z.string().optional(),\n\t\t\t\tnextUp: z.array(z.string()),\n\t\t\t}),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst { progress } = output\n\t\tconst lines = [\n\t\t\t`Phase: ${progress.phase}`,\n\t\t\t\"\",\n\t\t\t\"Components:\",\n\t\t\t`  Done: ${progress.components.done}/${progress.components.total}`,\n\t\t\t`  In Progress: ${progress.components.inProgress}`,\n\t\t\t`  Pending: ${progress.components.pending}`,\n\t\t\t`  Skipped: ${progress.components.skipped}`,\n\t\t\t\"\",\n\t\t\t\"Pages:\",\n\t\t\t`  Done: ${progress.pages.done}/${progress.pages.total}`,\n\t\t\t`  Ready: ${progress.pages.ready}`,\n\t\t\t`  Blocked: ${progress.pages.blocked}`,\n\t\t]\n\t\tif (progress.currentTask) {\n\t\t\tlines.push(\"\", `Current: ${progress.currentTask}`)\n\t\t}\n\t\tif (progress.nextUp.length > 0) {\n\t\t\tlines.push(\"\", `Next up: ${progress.nextUp.join(\", \")}`)\n\t\t}\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute() {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: \"Reading migration progress...\",\n\t\t}\n\n\t\tconst state = await readMigrationState()\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found. Use figmaFetch first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst components = Object.values(state.components)\n\t\tconst pages = Object.values(state.pages)\n\n\t\tconst inProgress = components.find((c) => c.status === \"in_progress\")\n\t\tconst inProgressPage = pages.find((p) => p.status === \"in_progress\")\n\n\t\tconst readyComponents = components\n\t\t\t.filter((c) => c.status === \"pending\" && c.dependenciesReady)\n\t\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n\n\t\tconst readyPages = pages.filter(\n\t\t\t(p) => p.status === \"pending\" && p.componentsReady,\n\t\t)\n\n\t\tlet nextUp: string[] = []\n\t\tif (state.stats.phase === \"components\") {\n\t\t\tnextUp = readyComponents.slice(0, 3).map((c) => c.name)\n\t\t} else if (state.stats.phase === \"pages\") {\n\t\t\tnextUp = readyPages.slice(0, 3).map((p) => p.frameName)\n\t\t}\n\n\t\tconst progress: MigrationProgressResult = {\n\t\t\tphase: state.stats.phase,\n\t\t\tcomponents: {\n\t\t\t\ttotal: components.length,\n\t\t\t\tdone: components.filter((c) => c.status === \"done\").length,\n\t\t\t\tinProgress: components.filter((c) => c.status === \"in_progress\").length,\n\t\t\t\tpending: components.filter((c) => c.status === \"pending\").length,\n\t\t\t\tskipped: components.filter((c) => c.status === \"skipped\").length,\n\t\t\t},\n\t\t\tpages: {\n\t\t\t\ttotal: pages.length,\n\t\t\t\tdone: pages.filter((p) => p.status === \"done\").length,\n\t\t\t\tready: readyPages.length,\n\t\t\t\tblocked: pages.filter((p) => p.status === \"blocked\").length,\n\t\t\t},\n\t\t\tcurrentTask: inProgress?.name || inProgressPage?.frameName,\n\t\t\tnextUp,\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"success\",\n\t\t\tmessage: \"Progress retrieved\",\n\t\t\tprogress,\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationNext\n// ============================================================================\n\nconst nextDescription = `Get the next items ready to be migrated.\n\nReturns items that:\n- For components: Have all dependencies completed\n- For pages: Have all required components completed\n\nItems are sorted by priority (instance count for components).`\n\nexport const migrationNext = tool({\n\tdescription: nextDescription,\n\tinputSchema: z.object({\n\t\tlimit: z.number().default(5).describe(\"Maximum number of items to return\"),\n\t\ttype: z\n\t\t\t.enum([\"component\", \"page\", \"any\"])\n\t\t\t.default(\"any\")\n\t\t\t.describe(\"Filter by item type\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tphase: z.string(),\n\t\t\titems: z.array(\n\t\t\t\tz.object({\n\t\t\t\t\ttype: z.enum([\"component\", \"page\"]),\n\t\t\t\t\tid: z.string(),\n\t\t\t\t\tname: z.string(),\n\t\t\t\t\tinstanceCount: z.number().optional(),\n\t\t\t\t\tdependencies: z.array(z.string()).optional(),\n\t\t\t\t\tcomponentsUsed: z.array(z.string()).optional(),\n\t\t\t\t}),\n\t\t\t),\n\t\t\tremaining: z.number(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tif (output.items.length === 0) {\n\t\t\treturn {\n\t\t\t\ttype: \"text\",\n\t\t\t\tvalue:\n\t\t\t\t\toutput.phase === \"done\"\n\t\t\t\t\t\t? \"Migration complete! All items have been processed.\"\n\t\t\t\t\t\t: \"No items ready. Some items may be blocked by dependencies.\",\n\t\t\t}\n\t\t}\n\t\tconst lines = output.items.map((item) => {\n\t\t\tif (item.type === \"component\") {\n\t\t\t\tconst deps = item.dependencies?.length\n\t\t\t\t\t? ` (deps: ${item.dependencies.length})`\n\t\t\t\t\t: \"\"\n\t\t\t\treturn `- [component] ${item.name} (${item.instanceCount}x)${deps}`\n\t\t\t}\n\t\t\treturn `- [page] ${item.name} (${item.componentsUsed?.length || 0} components)`\n\t\t})\n\t\tlines.push(\"\", `${output.remaining} more items remaining`)\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute({ limit, type }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: \"Finding next items...\",\n\t\t}\n\n\t\tconst state = await readMigrationState()\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found. Use figmaFetch first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst items: MigrationNextItem[] = []\n\n\t\tif (type === \"any\" || type === \"component\") {\n\t\t\tconst readyComponents = Object.values(state.components)\n\t\t\t\t.filter((c) => c.status === \"pending\" && c.dependenciesReady)\n\t\t\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n\n\t\t\tfor (const comp of readyComponents) {\n\t\t\t\titems.push({\n\t\t\t\t\ttype: \"component\",\n\t\t\t\t\tid: comp.figmaId,\n\t\t\t\t\tname: comp.name,\n\t\t\t\t\tinstanceCount: comp.instanceCount,\n\t\t\t\t\tdependencies: comp.dependencies,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tif ((type === \"any\" && state.stats.phase === \"pages\") || type === \"page\") {\n\t\t\tconst readyPages = Object.values(state.pages).filter(\n\t\t\t\t(p) => p.status === \"pending\" && p.componentsReady,\n\t\t\t)\n\n\t\t\tfor (const page of readyPages) {\n\t\t\t\titems.push({\n\t\t\t\t\ttype: \"page\",\n\t\t\t\t\tid: page.figmaId,\n\t\t\t\t\tname: page.frameName,\n\t\t\t\t\tcomponentsUsed: page.componentsUsed,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tconst remaining = items.length - limit\n\t\tconst limited = items.slice(0, limit)\n\n\t\tyield {\n\t\t\tstatus: \"success\",\n\t\t\tmessage: `Found ${items.length} ready items`,\n\t\t\tphase: state.stats.phase,\n\t\t\titems: limited,\n\t\t\tremaining: Math.max(0, remaining),\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationStart\n// ============================================================================\n\nconst startDescription = `Start working on a migration item.\n\nReturns the full Figma definition needed to implement the component or page.\nAfter implementing, call migrationComplete to mark it done.`\n\nexport const migrationStart = tool({\n\tdescription: startDescription,\n\tinputSchema: z.object({\n\t\tid: z.string().describe(\"The component or page ID to start working on\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\ttype: z.enum([\"component\", \"page\"]),\n\t\t\tid: z.string(),\n\t\t\tname: z.string(),\n\t\t\tdefinition: z.any(),\n\t\t\tsuggestedPath: z.string(),\n\t\t\tdependencies: z.array(z.string()).optional(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\treturn {\n\t\t\ttype: \"text\",\n\t\t\tvalue: JSON.stringify(output.definition, null, 2),\n\t\t}\n\t},\n\tasync *execute({ id }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Starting work on ${id}...`,\n\t\t}\n\n\t\tconst state = await readMigrationState()\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found. Use figmaFetch first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst component = state.components[id]\n\t\tif (component) {\n\t\t\tif (component.status === \"done\" || component.status === \"skipped\") {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Already processed\",\n\t\t\t\t\terror: `Component ${component.name} is already ${component.status}.`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (!component.dependenciesReady) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Dependencies not ready\",\n\t\t\t\t\terror: `Component ${component.name} has unfinished dependencies: ${component.dependencies.join(\", \")}`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tcomponent.status = \"in_progress\"\n\t\t\tawait writeMigrationState(state)\n\n\t\t\tconst compData = state.figmaData.components[id]\n\t\t\tconst safeName = component.name.replace(/[^a-zA-Z0-9]/g, \"\")\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Started component: ${component.name}`,\n\t\t\t\ttype: \"component\",\n\t\t\t\tid,\n\t\t\t\tname: component.name,\n\t\t\t\tdefinition: compData?.definition || null,\n\t\t\t\tsuggestedPath: `src/components/${safeName}.tsx`,\n\t\t\t\tdependencies: component.dependencies,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst page = state.pages[id]\n\t\tif (page) {\n\t\t\tif (page.status === \"done\") {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Already processed\",\n\t\t\t\t\terror: `Page ${page.frameName} is already done.`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (!page.componentsReady) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Components not ready\",\n\t\t\t\t\terror: `Page ${page.frameName} has unfinished components.`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpage.status = \"in_progress\"\n\t\t\tawait writeMigrationState(state)\n\n\t\t\tconst frame = state.figmaData.frames[id]\n\t\t\tconst safeName = page.frameName\n\t\t\t\t.toLowerCase()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-|-$/g, \"\")\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Started page: ${page.frameName}`,\n\t\t\t\ttype: \"page\",\n\t\t\t\tid,\n\t\t\t\tname: page.frameName,\n\t\t\t\tdefinition: frame?.definition || null,\n\t\t\t\tsuggestedPath: `src/app/${safeName}/page.tsx`,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"error\",\n\t\t\tmessage: \"Item not found\",\n\t\t\terror: `No component or page found with ID: ${id}`,\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationComplete\n// ============================================================================\n\nconst completeDescription = `Mark a migration item as complete.\n\nRecords the output path and updates dependency status for other items.\nReturns newly unlocked items.`\n\nexport const migrationComplete = tool({\n\tdescription: completeDescription,\n\tinputSchema: z.object({\n\t\tid: z.string().describe(\"The component or page ID that was completed\"),\n\t\toutputPath: z.string().describe(\"The file path where the item was written\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tcompleted: z.string(),\n\t\t\tnewReady: z.array(z.string()),\n\t\t\tprogress: z.object({\n\t\t\t\tdone: z.number(),\n\t\t\t\ttotal: z.number(),\n\t\t\t}),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst lines = [\n\t\t\t`Completed: ${output.completed}`,\n\t\t\t`Progress: ${output.progress.done}/${output.progress.total}`,\n\t\t]\n\t\tif (output.newReady.length > 0) {\n\t\t\tlines.push(`Newly ready: ${output.newReady.join(\", \")}`)\n\t\t}\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute({ id, outputPath }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Marking ${id} as complete...`,\n\t\t}\n\n\t\tconst state = await readMigrationState()\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst component = state.components[id]\n\t\tif (component) {\n\t\t\tconst wasNotReady = Object.values(state.components)\n\t\t\t\t.filter((c) => c.status === \"pending\" && !c.dependenciesReady)\n\t\t\t\t.map((c) => c.figmaId)\n\n\t\t\tcomponent.status = \"done\"\n\t\t\tcomponent.outputPath = outputPath\n\t\t\tcomponent.completedAt = new Date().toISOString()\n\n\t\t\tupdateDependencyReadiness(state)\n\t\t\tstate.stats = computeStats(state)\n\t\t\tawait writeMigrationState(state)\n\n\t\t\tconst newlyReady = Object.values(state.components)\n\t\t\t\t.filter(\n\t\t\t\t\t(c) =>\n\t\t\t\t\t\tc.status === \"pending\" &&\n\t\t\t\t\t\tc.dependenciesReady &&\n\t\t\t\t\t\twasNotReady.includes(c.figmaId),\n\t\t\t\t)\n\t\t\t\t.map((c) => c.name)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Completed component: ${component.name}`,\n\t\t\t\tcompleted: component.name,\n\t\t\t\tnewReady: newlyReady,\n\t\t\t\tprogress: {\n\t\t\t\t\tdone: state.stats.completedComponents,\n\t\t\t\t\ttotal: state.stats.totalComponents,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst page = state.pages[id]\n\t\tif (page) {\n\t\t\tpage.status = \"done\"\n\t\t\tpage.outputPath = outputPath\n\t\t\tpage.completedAt = new Date().toISOString()\n\n\t\t\tstate.stats = computeStats(state)\n\t\t\tawait writeMigrationState(state)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Completed page: ${page.frameName}`,\n\t\t\t\tcompleted: page.frameName,\n\t\t\t\tnewReady: [],\n\t\t\t\tprogress: {\n\t\t\t\t\tdone: state.stats.completedPages,\n\t\t\t\t\ttotal: state.stats.totalPages,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"error\",\n\t\t\tmessage: \"Item not found\",\n\t\t\terror: `No component or page found with ID: ${id}`,\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationSkip\n// ============================================================================\n\nconst skipDescription = `Skip a migration item (for external/existing components).\n\nSkipped items are treated as \"done\" for dependency purposes.`\n\nexport const migrationSkip = tool({\n\tdescription: skipDescription,\n\tinputSchema: z.object({\n\t\tid: z.string().describe(\"The component or page ID to skip\"),\n\t\treason: z\n\t\t\t.string()\n\t\t\t.describe(\"Reason for skipping (e.g., 'external component')\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tskipped: z.string(),\n\t\t\treason: z.string(),\n\t\t\tnewReady: z.array(z.string()),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst lines = [`Skipped: ${output.skipped}`, `Reason: ${output.reason}`]\n\t\tif (output.newReady.length > 0) {\n\t\t\tlines.push(`Newly ready: ${output.newReady.join(\", \")}`)\n\t\t}\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute({ id, reason }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Skipping ${id}...`,\n\t\t}\n\n\t\tconst state = await readMigrationState()\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst component = state.components[id]\n\t\tif (component) {\n\t\t\tconst wasNotReady = Object.values(state.components)\n\t\t\t\t.filter((c) => c.status === \"pending\" && !c.dependenciesReady)\n\t\t\t\t.map((c) => c.figmaId)\n\n\t\t\tcomponent.status = \"skipped\"\n\t\t\tcomponent.skipReason = reason\n\t\t\tcomponent.completedAt = new Date().toISOString()\n\n\t\t\tupdateDependencyReadiness(state)\n\t\t\tstate.stats = computeStats(state)\n\t\t\tawait writeMigrationState(state)\n\n\t\t\tconst newlyReady = Object.values(state.components)\n\t\t\t\t.filter(\n\t\t\t\t\t(c) =>\n\t\t\t\t\t\tc.status === \"pending\" &&\n\t\t\t\t\t\tc.dependenciesReady &&\n\t\t\t\t\t\twasNotReady.includes(c.figmaId),\n\t\t\t\t)\n\t\t\t\t.map((c) => c.name)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Skipped component: ${component.name}`,\n\t\t\t\tskipped: component.name,\n\t\t\t\treason,\n\t\t\t\tnewReady: newlyReady,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst page = state.pages[id]\n\t\tif (page) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"Cannot skip pages\",\n\t\t\t\terror: \"Pages cannot be skipped, only components.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"error\",\n\t\t\tmessage: \"Item not found\",\n\t\t\terror: `No component found with ID: ${id}`,\n\t\t}\n\t},\n})\n"
		},
		{
			"path": "tools/figma/lib/types.ts",
			"type": "registry:lib",
			"content": "// ============================================================================\n// Figma Node Types & Interfaces\n// Based on https://developers.figma.com/docs/rest-api/file-node-types/\n// ============================================================================\n\nexport interface Color {\n\tr: number\n\tg: number\n\tb: number\n\ta: number\n}\n\nexport interface Paint {\n\ttype:\n\t\t| \"SOLID\"\n\t\t| \"GRADIENT_LINEAR\"\n\t\t| \"GRADIENT_RADIAL\"\n\t\t| \"GRADIENT_ANGULAR\"\n\t\t| \"GRADIENT_DIAMOND\"\n\t\t| \"IMAGE\"\n\t\t| \"EMOJI\"\n\t\t| \"VIDEO\"\n\tvisible?: boolean\n\topacity?: number\n\tcolor?: Color\n\tblendMode?: string\n\tgradientHandlePositions?: { x: number; y: number }[]\n\tgradientStops?: { position: number; color: Color }[]\n\tscaleMode?: string\n\timageRef?: string\n}\n\nexport interface Effect {\n\ttype: \"INNER_SHADOW\" | \"DROP_SHADOW\" | \"LAYER_BLUR\" | \"BACKGROUND_BLUR\"\n\tvisible?: boolean\n\tradius: number\n\tcolor?: Color\n\tblendMode?: string\n\toffset?: { x: number; y: number }\n\tspread?: number\n}\n\nexport interface Constraint {\n\ttype: \"MIN\" | \"CENTER\" | \"MAX\" | \"STRETCH\" | \"SCALE\"\n\tvalue: number\n}\n\nexport interface Rectangle {\n\tx: number\n\ty: number\n\twidth: number\n\theight: number\n}\n\nexport interface TypeStyle {\n\tfontFamily?: string\n\tfontPostScriptName?: string\n\tfontWeight?: number\n\tfontSize?: number\n\ttextAlignHorizontal?: \"LEFT\" | \"RIGHT\" | \"CENTER\" | \"JUSTIFIED\"\n\ttextAlignVertical?: \"TOP\" | \"CENTER\" | \"BOTTOM\"\n\tletterSpacing?: number\n\tlineHeightPx?: number\n\tlineHeightPercent?: number\n\tlineHeightUnit?: string\n\ttextCase?: \"ORIGINAL\" | \"UPPER\" | \"LOWER\" | \"TITLE\"\n\ttextDecoration?: \"NONE\" | \"STRIKETHROUGH\" | \"UNDERLINE\"\n\tfills?: Paint[]\n}\n\nexport interface StrokeWeights {\n\ttop: number\n\tright: number\n\tbottom: number\n\tleft: number\n}\n\nexport interface FigmaNode {\n\tid: string\n\tname: string\n\ttype: string\n\tvisible?: boolean\n\tchildren?: FigmaNode[]\n\n\t// Instance-specific\n\tcomponentId?: string\n\n\t// Component-specific\n\tcomponentPropertyDefinitions?: Record<string, unknown>\n\n\t// Geometry\n\tabsoluteBoundingBox?: Rectangle\n\tabsoluteRenderBounds?: Rectangle\n\tsize?: { x: number; y: number }\n\trelativeTransform?: number[][]\n\n\t// Constraints & Layout\n\tconstraints?: { horizontal: string; vertical: string }\n\tlayoutAlign?: string\n\tlayoutGrow?: number\n\tlayoutPositioning?: string\n\n\t// Auto Layout (Flexbox)\n\tlayoutMode?: \"NONE\" | \"HORIZONTAL\" | \"VERTICAL\"\n\tprimaryAxisSizingMode?: \"FIXED\" | \"AUTO\"\n\tcounterAxisSizingMode?: \"FIXED\" | \"AUTO\"\n\tprimaryAxisAlignItems?: \"MIN\" | \"CENTER\" | \"MAX\" | \"SPACE_BETWEEN\"\n\tcounterAxisAlignItems?: \"MIN\" | \"CENTER\" | \"MAX\" | \"BASELINE\"\n\tpaddingLeft?: number\n\tpaddingRight?: number\n\tpaddingTop?: number\n\tpaddingBottom?: number\n\titemSpacing?: number\n\tcounterAxisSpacing?: number\n\tlayoutWrap?: \"NO_WRAP\" | \"WRAP\"\n\n\t// Appearance\n\tfills?: Paint[]\n\tstrokes?: Paint[]\n\tstrokeWeight?: number\n\tstrokeAlign?: \"INSIDE\" | \"OUTSIDE\" | \"CENTER\"\n\tstrokeCap?: string\n\tstrokeJoin?: string\n\tstrokeDashes?: number[]\n\tindividualStrokeWeights?: StrokeWeights\n\tcornerRadius?: number\n\trectangleCornerRadii?: number[]\n\teffects?: Effect[]\n\tblendMode?: string\n\topacity?: number\n\tisMask?: boolean\n\n\t// Clipping\n\tclipsContent?: boolean\n\n\t// Text-specific\n\tcharacters?: string\n\tstyle?: TypeStyle\n\tcharacterStyleOverrides?: number[]\n\tstyleOverrideTable?: Record<string, TypeStyle>\n\ttextAutoResize?: string\n\n\t// Vector-specific\n\tfillGeometry?: unknown[]\n\tstrokeGeometry?: unknown[]\n\n\t// Export settings\n\texportSettings?: unknown[]\n\n\t// Interactions/Prototyping\n\ttransitionNodeID?: string\n\ttransitionDuration?: number\n\ttransitionEasing?: string\n}\n\nexport interface FigmaFile {\n\tdocument: FigmaNode\n\tcomponents: Record<\n\t\tstring,\n\t\t{ name: string; description?: string; key?: string }\n\t>\n\tstyles?: Record<\n\t\tstring,\n\t\t{ name: string; styleType: string; description?: string }\n\t>\n}\n\n// ============================================================================\n// Extracted Data Types\n// ============================================================================\n\nexport interface FrameInfo {\n\tid: string\n\tname: string\n\ttype: string\n\tpageId: string\n\tsectionId?: string\n\tcomponentsUsed: string[]\n\tdefinition: FigmaNode | null\n}\n\nexport interface SectionInfo {\n\tid: string\n\tname: string\n\tparentSectionId?: string\n\tframeIds: string[]\n}\n\nexport interface PageInfo {\n\tid: string\n\tname: string\n\tsectionIds: string[]\n\tframeIds: string[]\n}\n\nexport interface ComponentData {\n\tname: string\n\tdescription?: string\n\tdefinition: FigmaNode | null\n\tusedInFrames: string[]\n\tinstanceCount: number\n}\n\nexport interface ExtractedData {\n\tpages: PageInfo[]\n\tsections: Record<string, SectionInfo>\n\tframes: Record<string, FrameInfo>\n\tcomponents: Record<string, ComponentData>\n}\n\nexport interface ExtractionConfig {\n\tskipInvisible?: boolean\n}\n\n// ============================================================================\n// Migration State Types\n// ============================================================================\n\nexport type MigrationPhase = \"components\" | \"pages\" | \"done\"\n\nexport type ComponentStatus = \"pending\" | \"in_progress\" | \"done\" | \"skipped\"\n\nexport type PageStatus = \"blocked\" | \"pending\" | \"in_progress\" | \"done\"\n\nexport interface ComponentState {\n\tfigmaId: string\n\tname: string\n\tstatus: ComponentStatus\n\tdependencies: string[]\n\tdependenciesReady: boolean\n\tinstanceCount: number\n\toutputPath?: string\n\tcompletedAt?: string\n\tskipReason?: string\n}\n\nexport interface PageState {\n\tfigmaId: string\n\tframeName: string\n\tstatus: PageStatus\n\tcomponentsUsed: string[]\n\tcomponentsReady: boolean\n\toutputPath?: string\n\tcompletedAt?: string\n}\n\nexport interface MigrationStats {\n\ttotalComponents: number\n\tcompletedComponents: number\n\tskippedComponents: number\n\ttotalPages: number\n\tcompletedPages: number\n\tphase: MigrationPhase\n}\n\nexport interface MigrationState {\n\tfigmaFileKey: string\n\tfigmaFileUrl: string\n\tcreatedAt: string\n\tupdatedAt: string\n\tstats: MigrationStats\n\tcomponents: Record<string, ComponentState>\n\tpages: Record<string, PageState>\n\t/** Post-processed Figma data for component/page definitions */\n\tfigmaData: ExtractedData\n}\n\n// ============================================================================\n// Tool Input/Output Types\n// ============================================================================\n\nexport interface MigrationNextItem {\n\ttype: \"component\" | \"page\"\n\tid: string\n\tname: string\n\tinstanceCount?: number\n\tdependencies?: string[]\n\tcomponentsUsed?: string[]\n}\n\nexport interface MigrationProgressResult {\n\tphase: MigrationPhase\n\tcomponents: {\n\t\ttotal: number\n\t\tdone: number\n\t\tinProgress: number\n\t\tpending: number\n\t\tskipped: number\n\t}\n\tpages: {\n\t\ttotal: number\n\t\tdone: number\n\t\tready: number\n\t\tblocked: number\n\t}\n\tcurrentTask?: string\n\tnextUp: string[]\n}\n"
		}
	]
}
