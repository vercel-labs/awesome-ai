{
	"name": "grep",
	"type": "registry:tool",
	"title": "Grep",
	"description": "Searches for patterns in files using ripgrep.",
	"dependencies": [
		"ai",
		"zod"
	],
	"files": [
		{
			"path": "tools/grep.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { promises as fs } from \"fs\"\nimport * as path from \"path\"\nimport { z } from \"zod\"\nimport * as ripgrep from \"@/tools/lib/ripgrep\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\n\nconst LIMIT = 100\n\ninterface Match {\n\tpath: string\n\tlineNum: number\n\tlineText: string\n\tmodTime: number\n}\n\n/**\n * Search using ripgrep\n */\nasync function searchFiles(\n\tsearchPath: string,\n\tpattern: string,\n\tinclude?: string,\n): Promise<Match[]> {\n\tconst glob = include ? [include] : undefined\n\n\tconst matches: Match[] = []\n\n\tfor await (const match of ripgrep.search({\n\t\tcwd: searchPath,\n\t\tpattern,\n\t\tglob,\n\t})) {\n\t\tconst fullPath = path.join(searchPath, match.path)\n\n\t\t// Get file modification time for sorting\n\t\tlet modTime = 0\n\t\ttry {\n\t\t\tconst stats = await fs.stat(fullPath)\n\t\t\tmodTime = stats.mtimeMs\n\t\t} catch {\n\t\t\t// File may have been deleted\n\t\t}\n\n\t\tmatches.push({\n\t\t\tpath: fullPath,\n\t\t\tlineNum: match.lineNumber,\n\t\t\tlineText: match.lineText.trim(),\n\t\t\tmodTime,\n\t\t})\n\n\t\tif (matches.length >= LIMIT) break\n\t}\n\n\treturn matches\n}\n\n/**\n * Format matches for output\n */\nfunction formatMatches(matches: Match[]): string {\n\tif (matches.length === 0) {\n\t\treturn \"No matches found\"\n\t}\n\n\t// Sort by modification time (most recent first)\n\tmatches.sort((a, b) => b.modTime - a.modTime)\n\n\tconst outputLines = [`Found ${matches.length} matches\\n`]\n\n\tlet currentFile = \"\"\n\tfor (const match of matches) {\n\t\tif (currentFile !== match.path) {\n\t\t\tif (currentFile !== \"\") {\n\t\t\t\toutputLines.push(\"\")\n\t\t\t}\n\t\t\tcurrentFile = match.path\n\t\t\toutputLines.push(`${match.path}:`)\n\t\t}\n\t\toutputLines.push(`  Line ${match.lineNum}: ${match.lineText}`)\n\t}\n\n\tif (matches.length >= LIMIT) {\n\t\toutputLines.push(\"\")\n\t\toutputLines.push(\n\t\t\t\"(Results are truncated. Consider using a more specific path or pattern.)\",\n\t\t)\n\t}\n\n\treturn outputLines.join(\"\\n\")\n}\n\nexport const grepTool = tool({\n\tdescription: `Searches for patterns in files using ripgrep.\n\nUsage:\n- Searches for regex patterns in file contents\n- Returns matching lines with file paths and line numbers\n- Results are sorted by file modification time (most recent first)\n- Results are limited to 100 matches\n- Respects .gitignore rules\n- Useful for finding specific code patterns, function definitions, variable usage, etc.`,\n\tinputSchema: z.object({\n\t\tpattern: z\n\t\t\t.string()\n\t\t\t.describe(\"The regex pattern to search for in file contents\"),\n\t\tpath: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\n\t\t\t\t\"The directory to search in. Defaults to the current working directory.\",\n\t\t\t),\n\t\tinclude: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\n\t\t\t\t'File pattern to include in the search (e.g. \"*.js\", \"*.{ts,tsx}\")',\n\t\t\t),\n\t}),\n\toutputSchema: toolOutput({\n\t\tpending: {\n\t\t\tpattern: z.string(),\n\t\t\tsearchPath: z.string(),\n\t\t\tresult: z.undefined(),\n\t\t},\n\t\tsuccess: {\n\t\t\tpattern: z.string(),\n\t\t\tsearchPath: z.string(),\n\t\t\tresult: z.string(),\n\t\t\tmatchCount: z.number(),\n\t\t},\n\t\terror: {\n\t\t\tpattern: z.string(),\n\t\t\tsearchPath: z.string(),\n\t\t},\n\t}),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn {\n\t\t\t\ttype: \"error-text\",\n\t\t\t\tvalue: `Error searching for \"${output.pattern}\" in ${output.searchPath}: ${output.error}`,\n\t\t\t}\n\t\t}\n\t\tif (output.status === \"success\") {\n\t\t\tif (output.matchCount === 0) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"text\",\n\t\t\t\t\tvalue: `No matches found for pattern \"${output.pattern}\"`,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"text\",\n\t\t\t\tvalue: `Found ${output.matchCount} matches for \"${output.pattern}\":\\n${output.result}`,\n\t\t\t}\n\t\t}\n\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t},\n\tasync *execute({ pattern, path: searchPath, include }) {\n\t\tconst cwd = searchPath || process.cwd()\n\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Searching for pattern: ${pattern}`,\n\t\t\tpattern,\n\t\t\tsearchPath: cwd,\n\t\t\tresult: undefined,\n\t\t}\n\n\t\ttry {\n\t\t\tconst matches = await searchFiles(cwd, pattern, include)\n\t\t\tconst result = formatMatches(matches)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Found ${matches.length} matches for pattern: ${pattern}`,\n\t\t\t\tpattern,\n\t\t\t\tsearchPath: cwd,\n\t\t\t\tresult,\n\t\t\t\tmatchCount: matches.length,\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: `Failed to search for pattern: ${pattern}`,\n\t\t\t\tpattern,\n\t\t\t\tsearchPath: cwd,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t}\n\t\t}\n\t},\n})\n"
		},
		{
			"path": "tools/lib/ripgrep.ts",
			"type": "registry:lib",
			"content": "import { type ChildProcess, execSync, spawn } from \"child_process\"\nimport * as fs from \"fs/promises\"\nimport * as os from \"os\"\nimport * as path from \"path\"\n\nconst RIPGREP_VERSION = \"14.1.1\"\n\nconst PLATFORM: Record<string, { name: string; ext: \"tar.gz\" | \"zip\" }> = {\n\t\"arm64-darwin\": { name: \"aarch64-apple-darwin\", ext: \"tar.gz\" },\n\t\"arm64-linux\": { name: \"aarch64-unknown-linux-gnu\", ext: \"tar.gz\" },\n\t\"x64-darwin\": { name: \"x86_64-apple-darwin\", ext: \"tar.gz\" },\n\t\"x64-linux\": { name: \"x86_64-unknown-linux-musl\", ext: \"tar.gz\" },\n\t\"x64-win32\": { name: \"x86_64-pc-windows-msvc\", ext: \"zip\" },\n}\n\nfunction getBinDir(): string {\n\treturn path.join(os.homedir(), \".cache\", \"awesome-ai\", \"bin\")\n}\n\nlet cachedRgPath: string | undefined\n\n/**\n * Get the path to the ripgrep binary.\n * Checks for system ripgrep first, then downloads from GitHub if needed.\n */\nexport async function getRipgrepPath(): Promise<string> {\n\tif (cachedRgPath) return cachedRgPath\n\n\t// 1. Check for system ripgrep\n\ttry {\n\t\tconst cmd = process.platform === \"win32\" ? \"where rg\" : \"which rg\"\n\t\tconst systemRg = execSync(cmd, { encoding: \"utf-8\" }).split(\"\\n\")[0]?.trim()\n\t\tif (systemRg) {\n\t\t\tcachedRgPath = systemRg\n\t\t\treturn systemRg\n\t\t}\n\t} catch {\n\t\t// Not found on system\n\t}\n\n\t// 2. Check if already downloaded\n\tconst binDir = getBinDir()\n\tconst rgPath = path.join(\n\t\tbinDir,\n\t\tprocess.platform === \"win32\" ? \"rg.exe\" : \"rg\",\n\t)\n\n\ttry {\n\t\tawait fs.access(rgPath, fs.constants.X_OK)\n\t\tcachedRgPath = rgPath\n\t\treturn rgPath\n\t} catch {\n\t\t// Not downloaded yet\n\t}\n\n\t// 3. Download from GitHub\n\tawait downloadRipgrep(binDir, rgPath)\n\tcachedRgPath = rgPath\n\treturn rgPath\n}\n\nasync function downloadRipgrep(binDir: string, rgPath: string): Promise<void> {\n\tconst platformKey = `${process.arch}-${process.platform}`\n\tconst config = PLATFORM[platformKey]\n\tif (!config) throw new Error(`Unsupported platform: ${platformKey}`)\n\n\tconst filename = `ripgrep-${RIPGREP_VERSION}-${config.name}.${config.ext}`\n\tconst url = `https://github.com/BurntSushi/ripgrep/releases/download/${RIPGREP_VERSION}/${filename}`\n\n\tawait fs.mkdir(binDir, { recursive: true })\n\tconst archivePath = path.join(binDir, filename)\n\n\t// Download\n\tconst response = await fetch(url)\n\tif (!response.ok)\n\t\tthrow new Error(`Failed to download ripgrep: ${response.status}`)\n\tawait fs.writeFile(archivePath, Buffer.from(await response.arrayBuffer()))\n\n\t// Extract\n\tif (config.ext === \"tar.gz\") {\n\t\tawait extractTarGz(archivePath, binDir, platformKey)\n\t} else {\n\t\tawait extractZip(archivePath, rgPath)\n\t}\n\n\t// Cleanup & permissions\n\tawait fs.unlink(archivePath)\n\tif (process.platform !== \"win32\") {\n\t\tawait fs.chmod(rgPath, 0o755)\n\t}\n}\n\nasync function extractTarGz(\n\tarchivePath: string,\n\tbinDir: string,\n\tplatformKey: string,\n): Promise<void> {\n\tconst args = [\"tar\", \"-xzf\", archivePath, \"--strip-components=1\"]\n\n\t// Platform-specific flags to extract only the rg binary\n\tif (platformKey.endsWith(\"-darwin\")) {\n\t\targs.push(\"--include=*/rg\")\n\t} else if (platformKey.endsWith(\"-linux\")) {\n\t\targs.push(\"--wildcards\", \"*/rg\")\n\t}\n\n\tawait new Promise<void>((resolve, reject) => {\n\t\tconst proc = spawn(args[0]!, args.slice(1), {\n\t\t\tcwd: binDir,\n\t\t\tstdio: [\"ignore\", \"pipe\", \"pipe\"],\n\t\t})\n\n\t\tlet stderr = \"\"\n\t\tproc.stderr?.on(\"data\", (chunk) => {\n\t\t\tstderr += chunk.toString()\n\t\t})\n\n\t\tproc.on(\"close\", (code) => {\n\t\t\tif (code !== 0) {\n\t\t\t\treject(new Error(`tar extraction failed: ${stderr}`))\n\t\t\t} else {\n\t\t\t\tresolve()\n\t\t\t}\n\t\t})\n\n\t\tproc.on(\"error\", reject)\n\t})\n}\n\nasync function extractZip(archivePath: string, rgPath: string): Promise<void> {\n\t// Dynamic import to avoid loading unzipper on non-Windows platforms\n\tconst unzipper = (await import(\"unzipper\")) as typeof import(\"unzipper\")\n\n\tconst directory = await unzipper.Open.file(archivePath)\n\tconst rgEntry = directory.files.find((f: { path: string }) =>\n\t\tf.path.endsWith(\"rg.exe\"),\n\t)\n\n\tif (!rgEntry) {\n\t\tthrow new Error(\"rg.exe not found in zip archive\")\n\t}\n\n\tconst content = await rgEntry.buffer()\n\tawait fs.writeFile(rgPath, content)\n}\n\nexport interface FilesOptions {\n\tcwd: string\n\tglob?: string[]\n}\n\n/**\n * Async generator that yields file paths using ripgrep.\n * Uses `rg --files` which is much faster than manual directory walking.\n *\n * @param opts.cwd - Directory to search in\n * @param opts.glob - Glob patterns (prefix with ! to exclude)\n * @yields File paths relative to cwd\n */\nexport async function* files(opts: FilesOptions): AsyncGenerator<string> {\n\tconst rgPath = await getRipgrepPath()\n\n\tconst args = [\n\t\t\"--files\",\n\t\t\"--follow\", // Follow symlinks\n\t\t\"--hidden\", // Include hidden files\n\t\t\"--glob=!.git/*\", // Always exclude .git\n\t]\n\n\t// Add custom glob patterns\n\tif (opts.glob) {\n\t\tfor (const g of opts.glob) {\n\t\t\targs.push(`--glob=${g}`)\n\t\t}\n\t}\n\n\tconst proc = spawn(rgPath, args, {\n\t\tcwd: opts.cwd,\n\t\tstdio: [\"ignore\", \"pipe\", \"ignore\"],\n\t})\n\n\tyield* streamLines(proc)\n}\n\nexport interface SearchOptions {\n\tcwd: string\n\tpattern: string\n\tglob?: string[]\n\tmaxCount?: number\n}\n\nexport interface SearchMatch {\n\tpath: string\n\tlineNumber: number\n\tlineText: string\n}\n\n/**\n * Search for a pattern in files using ripgrep.\n *\n * @param opts.cwd - Directory to search in\n * @param opts.pattern - Regex pattern to search for\n * @param opts.glob - Glob patterns to filter files\n * @param opts.maxCount - Maximum matches per file\n * @yields Search matches with file path, line number, and text\n */\nexport async function* search(\n\topts: SearchOptions,\n): AsyncGenerator<SearchMatch> {\n\tconst rgPath = await getRipgrepPath()\n\n\tconst args = [\n\t\t\"--line-number\", // Include line numbers\n\t\t\"--column\", // Include column numbers\n\t\t\"--no-heading\", // Don't group by file\n\t\t\"--with-filename\", // Always show filename\n\t\t\"--hidden\", // Include hidden files\n\t\t\"--glob=!.git/*\", // Always exclude .git\n\t]\n\n\t// Add custom glob patterns\n\tif (opts.glob) {\n\t\tfor (const g of opts.glob) {\n\t\t\targs.push(`--glob=${g}`)\n\t\t}\n\t}\n\n\tif (opts.maxCount) {\n\t\targs.push(`--max-count=${opts.maxCount}`)\n\t}\n\n\targs.push(\"--\", opts.pattern)\n\n\tconst proc = spawn(rgPath, args, {\n\t\tcwd: opts.cwd,\n\t\tstdio: [\"ignore\", \"pipe\", \"ignore\"],\n\t})\n\n\tfor await (const line of streamLines(proc)) {\n\t\t// Parse ripgrep output: filename:line:column:text\n\t\tconst match = line.match(/^([^:]+):(\\d+):\\d+:(.*)$/)\n\t\tif (match) {\n\t\t\tyield {\n\t\t\t\tpath: match[1]!,\n\t\t\t\tlineNumber: parseInt(match[2]!, 10),\n\t\t\t\tlineText: match[3]!,\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Stream lines from a child process stdout\n */\nasync function* streamLines(proc: ChildProcess): AsyncGenerator<string> {\n\tconst stdout = proc.stdout\n\tif (!stdout) return\n\n\t// Set up close handler BEFORE consuming stdout to avoid race condition\n\tconst closePromise = new Promise<void>((resolve) => {\n\t\tproc.once(\"close\", () => resolve())\n\t})\n\n\tlet buffer = \"\"\n\n\tfor await (const chunk of stdout) {\n\t\tbuffer += chunk.toString()\n\t\tconst lines = buffer.split(\"\\n\")\n\t\tbuffer = lines.pop() || \"\"\n\n\t\tfor (const line of lines) {\n\t\t\tif (line) yield line\n\t\t}\n\t}\n\n\t// Yield any remaining content\n\tif (buffer) yield buffer\n\n\t// Wait for process to exit\n\tawait closePromise\n}\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		}
	]
}
