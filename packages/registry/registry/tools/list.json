{
	"name": "list",
	"type": "registry:tool",
	"title": "List",
	"description": "Lists files and directories in a given path.",
	"dependencies": [
		"ai",
		"zod"
	],
	"files": [
		{
			"path": "tools/list.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { promises as fs } from \"fs\"\nimport * as path from \"path\"\nimport { z } from \"zod\"\nimport * as ripgrep from \"@/tools/lib/ripgrep\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\n\nconst IGNORE_PATTERNS = [\n\t\"node_modules\",\n\t\"__pycache__\",\n\t\".git\",\n\t\"dist\",\n\t\"build\",\n\t\"target\",\n\t\"vendor\",\n\t\"bin\",\n\t\"obj\",\n\t\".idea\",\n\t\".vscode\",\n\t\".zig-cache\",\n\t\"zig-out\",\n\t\".coverage\",\n\t\"coverage\",\n\t\"tmp\",\n\t\"temp\",\n\t\".cache\",\n\t\"cache\",\n\t\"logs\",\n\t\".venv\",\n\t\"venv\",\n\t\"env\",\n]\n\nconst LIMIT = 100\n\n/**\n * List files using ripgrep\n */\nasync function listFiles(\n\tsearchPath: string,\n\tignorePatterns: string[],\n\tlimit: number,\n): Promise<string[]> {\n\t// Convert ignore patterns to ripgrep glob format\n\t// Handles patterns that already start with `!` to avoid double negation\n\tconst globs = ignorePatterns.map((p) => (p.startsWith(\"!\") ? p : `!${p}/*`))\n\n\tconst files: string[] = []\n\tfor await (const file of ripgrep.files({ cwd: searchPath, glob: globs })) {\n\t\tfiles.push(file)\n\t\tif (files.length >= limit) break\n\t}\n\n\treturn files\n}\n\n/**\n * Build a tree-style directory structure from file paths\n */\nfunction buildTree(files: string[], rootPath: string): string {\n\tconst dirs = new Set<string>()\n\tconst filesByDir = new Map<string, string[]>()\n\n\tfor (const file of files) {\n\t\tconst dir = path.dirname(file)\n\t\tconst parts = dir === \".\" ? [] : dir.split(path.sep)\n\n\t\t// Add all parent directories\n\t\tfor (let i = 0; i <= parts.length; i++) {\n\t\t\tconst dirPath = i === 0 ? \".\" : parts.slice(0, i).join(path.sep)\n\t\t\tdirs.add(dirPath)\n\t\t}\n\n\t\t// Add file to its directory\n\t\tif (!filesByDir.has(dir)) filesByDir.set(dir, [])\n\t\tfilesByDir.get(dir)!.push(path.basename(file))\n\t}\n\n\tfunction renderDir(dirPath: string, depth: number): string {\n\t\tconst indent = \"  \".repeat(depth)\n\t\tlet output = \"\"\n\n\t\tif (depth > 0) {\n\t\t\toutput += `${indent}${path.basename(dirPath)}/\\n`\n\t\t}\n\n\t\tconst childIndent = \"  \".repeat(depth + 1)\n\t\tconst children = Array.from(dirs)\n\t\t\t.filter((d) => path.dirname(d) === dirPath && d !== dirPath)\n\t\t\t.sort()\n\n\t\t// Render subdirectories first\n\t\tfor (const child of children) {\n\t\t\toutput += renderDir(child, depth + 1)\n\t\t}\n\n\t\t// Render files\n\t\tconst dirFiles = filesByDir.get(dirPath) || []\n\t\tfor (const file of dirFiles.sort()) {\n\t\t\toutput += `${childIndent}${file}\\n`\n\t\t}\n\n\t\treturn output\n\t}\n\n\treturn `${rootPath}/\\n${renderDir(\".\", 0)}`\n}\n\nconst description = `Lists files and directories in a given path.\n\nUsage:\n- Lists files in a directory recursively\n- Uses ripgrep for fast file listing\n- Automatically ignores common build and dependency directories\n- Respects .gitignore rules\n- Results are limited to 100 files\n- Displays directory structure in a tree format`\n\nexport const listTool = tool({\n\tdescription,\n\tinputSchema: z.object({\n\t\tpath: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\n\t\t\t\t\"The path to the directory to list (defaults to current directory)\",\n\t\t\t),\n\t\tignore: z\n\t\t\t.array(z.string())\n\t\t\t.optional()\n\t\t\t.describe(\n\t\t\t\t\"Additional patterns to ignore. Can be directory names (e.g., 'logs') or full glob patterns (e.g., '!*.tmp')\",\n\t\t\t),\n\t}),\n\toutputSchema: toolOutput({\n\t\tpending: {\n\t\t\tdirPath: z.string(),\n\t\t\tresult: z.undefined(),\n\t\t},\n\t\tsuccess: {\n\t\t\tdirPath: z.string(),\n\t\t\tresult: z.string(),\n\t\t\tfileCount: z.number(),\n\t\t},\n\t\terror: {\n\t\t\tdirPath: z.string(),\n\t\t},\n\t}),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn {\n\t\t\t\ttype: \"error-text\",\n\t\t\t\tvalue: `Error listing ${output.dirPath}: ${output.error}`,\n\t\t\t}\n\t\t}\n\t\tif (output.status === \"success\") {\n\t\t\treturn { type: \"text\", value: output.result }\n\t\t}\n\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t},\n\tasync *execute({ path: searchPath = \".\", ignore = [] }) {\n\t\tconst resolvedPath = path.resolve(process.cwd(), searchPath)\n\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Listing directory: ${resolvedPath}`,\n\t\t\tdirPath: resolvedPath,\n\t\t\tresult: undefined,\n\t\t}\n\n\t\ttry {\n\t\t\t// Verify directory exists\n\t\t\ttry {\n\t\t\t\tawait fs.access(resolvedPath)\n\t\t\t} catch {\n\t\t\t\tthrow new Error(`Directory not found: ${resolvedPath}`)\n\t\t\t}\n\n\t\t\tconst stats = await fs.stat(resolvedPath)\n\t\t\tif (!stats.isDirectory()) {\n\t\t\t\tthrow new Error(`Path is not a directory: ${resolvedPath}`)\n\t\t\t}\n\n\t\t\tconst allIgnorePatterns = [...IGNORE_PATTERNS, ...ignore]\n\t\t\tconst files = await listFiles(resolvedPath, allIgnorePatterns, LIMIT)\n\n\t\t\tconst output = buildTree(files, resolvedPath)\n\t\t\tconst truncated = files.length >= LIMIT\n\t\t\tconst result =\n\t\t\t\toutput + (truncated ? \"\\n(Results truncated to 100 files)\" : \"\")\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Found ${files.length} files in ${resolvedPath}`,\n\t\t\t\tdirPath: resolvedPath,\n\t\t\t\tresult,\n\t\t\t\tfileCount: files.length,\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: `Failed to list ${resolvedPath}`,\n\t\t\t\tdirPath: resolvedPath,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t}\n\t\t}\n\t},\n})\n"
		},
		{
			"path": "tools/lib/ripgrep.ts",
			"type": "registry:lib",
			"content": "import { type ChildProcess, execSync, spawn } from \"child_process\"\nimport * as fs from \"fs/promises\"\nimport * as os from \"os\"\nimport * as path from \"path\"\n\nconst RIPGREP_VERSION = \"14.1.1\"\n\nconst PLATFORM: Record<string, { name: string; ext: \"tar.gz\" | \"zip\" }> = {\n\t\"arm64-darwin\": { name: \"aarch64-apple-darwin\", ext: \"tar.gz\" },\n\t\"arm64-linux\": { name: \"aarch64-unknown-linux-gnu\", ext: \"tar.gz\" },\n\t\"x64-darwin\": { name: \"x86_64-apple-darwin\", ext: \"tar.gz\" },\n\t\"x64-linux\": { name: \"x86_64-unknown-linux-musl\", ext: \"tar.gz\" },\n\t\"x64-win32\": { name: \"x86_64-pc-windows-msvc\", ext: \"zip\" },\n}\n\nfunction getBinDir(): string {\n\treturn path.join(os.homedir(), \".cache\", \"awesome-ai\", \"bin\")\n}\n\nlet cachedRgPath: string | undefined\n\n/**\n * Get the path to the ripgrep binary.\n * Checks for system ripgrep first, then downloads from GitHub if needed.\n */\nexport async function getRipgrepPath(): Promise<string> {\n\tif (cachedRgPath) return cachedRgPath\n\n\t// 1. Check for system ripgrep\n\ttry {\n\t\tconst cmd = process.platform === \"win32\" ? \"where rg\" : \"which rg\"\n\t\tconst systemRg = execSync(cmd, { encoding: \"utf-8\" }).split(\"\\n\")[0]?.trim()\n\t\tif (systemRg) {\n\t\t\tcachedRgPath = systemRg\n\t\t\treturn systemRg\n\t\t}\n\t} catch {\n\t\t// Not found on system\n\t}\n\n\t// 2. Check if already downloaded\n\tconst binDir = getBinDir()\n\tconst rgPath = path.join(\n\t\tbinDir,\n\t\tprocess.platform === \"win32\" ? \"rg.exe\" : \"rg\",\n\t)\n\n\ttry {\n\t\tawait fs.access(rgPath, fs.constants.X_OK)\n\t\tcachedRgPath = rgPath\n\t\treturn rgPath\n\t} catch {\n\t\t// Not downloaded yet\n\t}\n\n\t// 3. Download from GitHub\n\tawait downloadRipgrep(binDir, rgPath)\n\tcachedRgPath = rgPath\n\treturn rgPath\n}\n\nasync function downloadRipgrep(binDir: string, rgPath: string): Promise<void> {\n\tconst platformKey = `${process.arch}-${process.platform}`\n\tconst config = PLATFORM[platformKey]\n\tif (!config) throw new Error(`Unsupported platform: ${platformKey}`)\n\n\tconst filename = `ripgrep-${RIPGREP_VERSION}-${config.name}.${config.ext}`\n\tconst url = `https://github.com/BurntSushi/ripgrep/releases/download/${RIPGREP_VERSION}/${filename}`\n\n\tawait fs.mkdir(binDir, { recursive: true })\n\tconst archivePath = path.join(binDir, filename)\n\n\t// Download\n\tconst response = await fetch(url)\n\tif (!response.ok)\n\t\tthrow new Error(`Failed to download ripgrep: ${response.status}`)\n\tawait fs.writeFile(archivePath, Buffer.from(await response.arrayBuffer()))\n\n\t// Extract\n\tif (config.ext === \"tar.gz\") {\n\t\tawait extractTarGz(archivePath, binDir, platformKey)\n\t} else {\n\t\tawait extractZip(archivePath, rgPath)\n\t}\n\n\t// Cleanup & permissions\n\tawait fs.unlink(archivePath)\n\tif (process.platform !== \"win32\") {\n\t\tawait fs.chmod(rgPath, 0o755)\n\t}\n}\n\nasync function extractTarGz(\n\tarchivePath: string,\n\tbinDir: string,\n\tplatformKey: string,\n): Promise<void> {\n\tconst args = [\"tar\", \"-xzf\", archivePath, \"--strip-components=1\"]\n\n\t// Platform-specific flags to extract only the rg binary\n\tif (platformKey.endsWith(\"-darwin\")) {\n\t\targs.push(\"--include=*/rg\")\n\t} else if (platformKey.endsWith(\"-linux\")) {\n\t\targs.push(\"--wildcards\", \"*/rg\")\n\t}\n\n\tawait new Promise<void>((resolve, reject) => {\n\t\tconst proc = spawn(args[0]!, args.slice(1), {\n\t\t\tcwd: binDir,\n\t\t\tstdio: [\"ignore\", \"pipe\", \"pipe\"],\n\t\t})\n\n\t\tlet stderr = \"\"\n\t\tproc.stderr?.on(\"data\", (chunk) => {\n\t\t\tstderr += chunk.toString()\n\t\t})\n\n\t\tproc.on(\"close\", (code) => {\n\t\t\tif (code !== 0) {\n\t\t\t\treject(new Error(`tar extraction failed: ${stderr}`))\n\t\t\t} else {\n\t\t\t\tresolve()\n\t\t\t}\n\t\t})\n\n\t\tproc.on(\"error\", reject)\n\t})\n}\n\nasync function extractZip(archivePath: string, rgPath: string): Promise<void> {\n\t// Dynamic import to avoid loading unzipper on non-Windows platforms\n\tconst unzipper = (await import(\"unzipper\")) as typeof import(\"unzipper\")\n\n\tconst directory = await unzipper.Open.file(archivePath)\n\tconst rgEntry = directory.files.find((f: { path: string }) =>\n\t\tf.path.endsWith(\"rg.exe\"),\n\t)\n\n\tif (!rgEntry) {\n\t\tthrow new Error(\"rg.exe not found in zip archive\")\n\t}\n\n\tconst content = await rgEntry.buffer()\n\tawait fs.writeFile(rgPath, content)\n}\n\nexport interface FilesOptions {\n\tcwd: string\n\tglob?: string[]\n}\n\n/**\n * Async generator that yields file paths using ripgrep.\n * Uses `rg --files` which is much faster than manual directory walking.\n *\n * @param opts.cwd - Directory to search in\n * @param opts.glob - Glob patterns (prefix with ! to exclude)\n * @yields File paths relative to cwd\n */\nexport async function* files(opts: FilesOptions): AsyncGenerator<string> {\n\tconst rgPath = await getRipgrepPath()\n\n\tconst args = [\n\t\t\"--files\",\n\t\t\"--follow\", // Follow symlinks\n\t\t\"--hidden\", // Include hidden files\n\t\t\"--glob=!.git/*\", // Always exclude .git\n\t]\n\n\t// Add custom glob patterns\n\tif (opts.glob) {\n\t\tfor (const g of opts.glob) {\n\t\t\targs.push(`--glob=${g}`)\n\t\t}\n\t}\n\n\tconst proc = spawn(rgPath, args, {\n\t\tcwd: opts.cwd,\n\t\tstdio: [\"ignore\", \"pipe\", \"ignore\"],\n\t})\n\n\tyield* streamLines(proc)\n}\n\nexport interface SearchOptions {\n\tcwd: string\n\tpattern: string\n\tglob?: string[]\n\tmaxCount?: number\n}\n\nexport interface SearchMatch {\n\tpath: string\n\tlineNumber: number\n\tlineText: string\n}\n\n/**\n * Search for a pattern in files using ripgrep.\n *\n * @param opts.cwd - Directory to search in\n * @param opts.pattern - Regex pattern to search for\n * @param opts.glob - Glob patterns to filter files\n * @param opts.maxCount - Maximum matches per file\n * @yields Search matches with file path, line number, and text\n */\nexport async function* search(\n\topts: SearchOptions,\n): AsyncGenerator<SearchMatch> {\n\tconst rgPath = await getRipgrepPath()\n\n\tconst args = [\n\t\t\"--line-number\", // Include line numbers\n\t\t\"--column\", // Include column numbers\n\t\t\"--no-heading\", // Don't group by file\n\t\t\"--with-filename\", // Always show filename\n\t\t\"--hidden\", // Include hidden files\n\t\t\"--glob=!.git/*\", // Always exclude .git\n\t]\n\n\t// Add custom glob patterns\n\tif (opts.glob) {\n\t\tfor (const g of opts.glob) {\n\t\t\targs.push(`--glob=${g}`)\n\t\t}\n\t}\n\n\tif (opts.maxCount) {\n\t\targs.push(`--max-count=${opts.maxCount}`)\n\t}\n\n\targs.push(\"--\", opts.pattern)\n\n\tconst proc = spawn(rgPath, args, {\n\t\tcwd: opts.cwd,\n\t\tstdio: [\"ignore\", \"pipe\", \"ignore\"],\n\t})\n\n\tfor await (const line of streamLines(proc)) {\n\t\t// Parse ripgrep output: filename:line:column:text\n\t\tconst match = line.match(/^([^:]+):(\\d+):\\d+:(.*)$/)\n\t\tif (match) {\n\t\t\tyield {\n\t\t\t\tpath: match[1]!,\n\t\t\t\tlineNumber: parseInt(match[2]!, 10),\n\t\t\t\tlineText: match[3]!,\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Stream lines from a child process stdout\n */\nasync function* streamLines(proc: ChildProcess): AsyncGenerator<string> {\n\tconst stdout = proc.stdout\n\tif (!stdout) return\n\n\t// Set up close handler BEFORE consuming stdout to avoid race condition\n\tconst closePromise = new Promise<void>((resolve) => {\n\t\tproc.once(\"close\", () => resolve())\n\t})\n\n\tlet buffer = \"\"\n\n\tfor await (const chunk of stdout) {\n\t\tbuffer += chunk.toString()\n\t\tconst lines = buffer.split(\"\\n\")\n\t\tbuffer = lines.pop() || \"\"\n\n\t\tfor (const line of lines) {\n\t\t\tif (line) yield line\n\t\t}\n\t}\n\n\t// Yield any remaining content\n\tif (buffer) yield buffer\n\n\t// Wait for process to exit\n\tawait closePromise\n}\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		}
	]
}
