{
	"name": "read",
	"type": "registry:tool",
	"title": "Read",
	"description": "Reads a file from the local filesystem. You can access any file directly by using this tool.",
	"dependencies": [
		"ai",
		"zod"
	],
	"files": [
		{
			"path": "tools/read.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { promises as fs } from \"fs\"\nimport * as path from \"path\"\nimport { z } from \"zod\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\n\nconst DEFAULT_READ_LIMIT = 2000\nconst MAX_LINE_LENGTH = 2000\n\n/**\n * Known binary file extensions - skip byte analysis for these\n */\nconst BINARY_EXTENSIONS = new Set([\n\t// Archives\n\t\".zip\",\n\t\".tar\",\n\t\".gz\",\n\t\".7z\",\n\t\".rar\",\n\t\".bz2\",\n\t\".xz\",\n\t// Executables\n\t\".exe\",\n\t\".dll\",\n\t\".so\",\n\t\".dylib\",\n\t\".bin\",\n\t// Java\n\t\".class\",\n\t\".jar\",\n\t\".war\",\n\t// Documents\n\t\".doc\",\n\t\".docx\",\n\t\".xls\",\n\t\".xlsx\",\n\t\".ppt\",\n\t\".pptx\",\n\t\".pdf\",\n\t\".odt\",\n\t\".ods\",\n\t\".odp\",\n\t// Images\n\t\".png\",\n\t\".jpg\",\n\t\".jpeg\",\n\t\".gif\",\n\t\".bmp\",\n\t\".webp\",\n\t\".ico\",\n\t\".svg\",\n\t// Audio/Video\n\t\".mp3\",\n\t\".mp4\",\n\t\".wav\",\n\t\".avi\",\n\t\".mkv\",\n\t\".mov\",\n\t// Compiled/Object files\n\t\".o\",\n\t\".obj\",\n\t\".a\",\n\t\".lib\",\n\t\".wasm\",\n\t\".pyc\",\n\t\".pyo\",\n\t// Data\n\t\".dat\",\n\t\".db\",\n\t\".sqlite\",\n\t\".sqlite3\",\n])\n\n/**\n * Sensitive file patterns that should be blocked\n */\nfunction isSensitiveFile(filepath: string): boolean {\n\tconst basename = path.basename(filepath)\n\n\t// Whitelist: allow example/sample env files\n\tconst whitelist = [\n\t\t\".env.sample\",\n\t\t\".env.example\",\n\t\t\".env.template\",\n\t\t\".env.local.example\",\n\t]\n\tif (whitelist.some((w) => basename.endsWith(w) || basename === w.slice(1))) {\n\t\treturn false\n\t}\n\n\t// Block .env files\n\tif (basename.includes(\".env\")) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n/**\n * Check if a path is contained within a directory\n */\nfunction isPathWithin(directory: string, filepath: string): boolean {\n\tconst relative = path.relative(directory, filepath)\n\treturn !relative.startsWith(\"..\") && !path.isAbsolute(relative)\n}\n\n/**\n * Check if file is binary using extension fast-path and byte analysis\n */\nasync function isBinaryFile(filepath: string): Promise<boolean> {\n\tconst ext = path.extname(filepath).toLowerCase()\n\n\t// Fast-path: known binary extensions\n\tif (BINARY_EXTENSIONS.has(ext)) {\n\t\treturn true\n\t}\n\n\t// Byte analysis for unknown extensions\n\tconst fileHandle = await fs.open(filepath, \"r\")\n\ttry {\n\t\tconst buffer = Buffer.alloc(4096)\n\t\tconst { bytesRead } = await fileHandle.read(buffer, 0, 4096, 0)\n\n\t\tif (bytesRead === 0) return false\n\n\t\tconst slice = buffer.slice(0, bytesRead)\n\t\tlet nonPrintableCount = 0\n\n\t\tfor (let i = 0; i < slice.length; i++) {\n\t\t\tconst byte = slice[i]\n\t\t\tif (byte === undefined) continue\n\n\t\t\t// Null byte = definitely binary\n\t\t\tif (byte === 0) {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// Count non-printable characters (excluding common whitespace)\n\t\t\tif (byte < 9 || (byte > 13 && byte < 32)) {\n\t\t\t\tnonPrintableCount++\n\t\t\t}\n\t\t}\n\n\t\t// >30% non-printable = binary\n\t\treturn nonPrintableCount / slice.length > 0.3\n\t} finally {\n\t\tawait fileHandle.close()\n\t}\n}\n\nexport const readTool = tool({\n\tdescription: `Reads a file from the local filesystem. You can access any file directly by using this tool.\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\n\nUsage:\n- The filePath parameter must be an absolute path, not a relative path\n- By default, it reads up to 2000 lines starting from the beginning of the file\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\n- Any lines longer than 2000 characters will be truncated\n- Results are returned using cat -n format, with line numbers starting at 1\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful.\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.\n- Sensitive files like .env are blocked for security (but .env.example, .env.sample are allowed).\n- Binary files cannot be read and will return an error.`,\n\tinputSchema: z.object({\n\t\tfilePath: z.string().describe(\"The path to the file to read\"),\n\t\toffset: z\n\t\t\t.number()\n\t\t\t.default(0)\n\t\t\t.describe(\"The line number to start reading from (0-based)\"),\n\t\tlimit: z\n\t\t\t.number()\n\t\t\t.default(DEFAULT_READ_LIMIT)\n\t\t\t.describe(\"The number of lines to read (defaults to 2000)\"),\n\t}),\n\toutputSchema: toolOutput({\n\t\tpending: {\n\t\t\tfilePath: z.string(),\n\t\t\tcontent: z.undefined(),\n\t\t},\n\t\tsuccess: {\n\t\t\tfilePath: z.string(),\n\t\t\tcontent: z.string(),\n\t\t\tlinesRead: z.number(),\n\t\t\ttotalLines: z.number(),\n\t\t\twarning: z.string().optional(),\n\t\t},\n\t\terror: {\n\t\t\tfilePath: z.string(),\n\t\t},\n\t}),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn {\n\t\t\t\ttype: \"error-text\",\n\t\t\t\tvalue: `Error reading ${output.filePath}: ${output.error}`,\n\t\t\t}\n\t\t}\n\t\tif (output.status === \"success\") {\n\t\t\tlet result = output.content\n\n\t\t\t// Add warning if present\n\t\t\tif (output.warning) {\n\t\t\t\tresult = `⚠️ ${output.warning}\\n\\n${result}`\n\t\t\t}\n\n\t\t\treturn { type: \"text\", value: result }\n\t\t}\n\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t},\n\tasync *execute({ filePath, offset, limit }) {\n\t\tlet filepath = filePath\n\t\tif (!path.isAbsolute(filepath)) {\n\t\t\tfilepath = path.join(process.cwd(), filepath)\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Reading file: ${filepath}`,\n\t\t\tfilePath: filepath,\n\t\t\tcontent: undefined,\n\t\t}\n\n\t\ttry {\n\t\t\t// Check for sensitive files\n\t\t\tif (isSensitiveFile(filepath)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot read sensitive file: ${filepath}\\nFor security, .env files are blocked. Use .env.example or .env.sample instead.`,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Check if reading outside working directory\n\t\t\tconst cwd = process.cwd()\n\t\t\tlet warning: string | undefined\n\t\t\tif (!isPathWithin(cwd, filepath)) {\n\t\t\t\twarning = `Reading file outside working directory: ${filepath}`\n\t\t\t}\n\n\t\t\t// Check if file exists\n\t\t\ttry {\n\t\t\t\tawait fs.access(filepath)\n\t\t\t} catch {\n\t\t\t\tconst dir = path.dirname(filepath)\n\t\t\t\tconst base = path.basename(filepath)\n\n\t\t\t\ttry {\n\t\t\t\t\tconst dirEntries = await fs.readdir(dir)\n\t\t\t\t\tconst suggestions = dirEntries\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t(entry) =>\n\t\t\t\t\t\t\t\tentry.toLowerCase().includes(base.toLowerCase()) ||\n\t\t\t\t\t\t\t\tbase.toLowerCase().includes(entry.toLowerCase()),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map((entry) => path.join(dir, entry))\n\t\t\t\t\t\t.slice(0, 3)\n\n\t\t\t\t\tif (suggestions.length > 0) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`File not found: ${filepath}\\n\\nDid you mean one of these?\\n${suggestions.join(\"\\n\")}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Directory doesn't exist or can't be read - rethrow if it's our suggestion error\n\t\t\t\t\tif (e instanceof Error && e.message.includes(\"Did you mean\")) {\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`File not found: ${filepath}`)\n\t\t\t}\n\n\t\t\t// Check if it's a directory\n\t\t\tconst stats = await fs.stat(filepath)\n\t\t\tif (stats.isDirectory()) {\n\t\t\t\tthrow new Error(`Path is a directory, not a file: ${filepath}`)\n\t\t\t}\n\n\t\t\t// Check if file is binary\n\t\t\tif (await isBinaryFile(filepath)) {\n\t\t\t\tthrow new Error(`Cannot read binary file: ${filepath}`)\n\t\t\t}\n\n\t\t\t// Read and process the file\n\t\t\tconst content = await fs.readFile(filepath, \"utf-8\")\n\t\t\tconst lines = content.split(\"\\n\")\n\t\t\tconst totalLines = lines.length\n\n\t\t\tconst raw = lines.slice(offset, offset + limit).map((line) => {\n\t\t\t\treturn line.length > MAX_LINE_LENGTH\n\t\t\t\t\t? `${line.substring(0, MAX_LINE_LENGTH)}...`\n\t\t\t\t\t: line\n\t\t\t})\n\n\t\t\tconst formattedLines = raw.map((line, index) => {\n\t\t\t\treturn `${(index + offset + 1).toString().padStart(5, \"0\")}| ${line}`\n\t\t\t})\n\n\t\t\tlet output = \"<file>\\n\"\n\t\t\toutput += formattedLines.join(\"\\n\")\n\n\t\t\tconst lastReadLine = offset + formattedLines.length\n\t\t\tconst hasMoreLines = totalLines > lastReadLine\n\n\t\t\tif (hasMoreLines) {\n\t\t\t\toutput += `\\n\\n(File has more lines. Use 'offset' parameter to read beyond line ${lastReadLine})`\n\t\t\t} else {\n\t\t\t\toutput += `\\n\\n(End of file - total ${totalLines} lines)`\n\t\t\t}\n\t\t\toutput += \"\\n</file>\"\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Successfully read ${formattedLines.length} lines from ${filepath}`,\n\t\t\t\tfilePath: filepath,\n\t\t\t\tcontent: output,\n\t\t\t\tlinesRead: formattedLines.length,\n\t\t\t\ttotalLines,\n\t\t\t\twarning,\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: `Failed to read ${filepath}`,\n\t\t\t\tfilePath: filepath,\n\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t}\n\t\t}\n\t},\n})\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		}
	]
}
