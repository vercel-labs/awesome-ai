{
	"name": "write",
	"type": "registry:tool",
	"title": "Write",
	"description": "Writes a file to the local filesystem.",
	"dependencies": ["ai", "diff", "zod"],
	"files": [
		{
			"path": "tools/write.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { createTwoFilesPatch } from \"diff\"\nimport { promises as fs } from \"fs\"\nimport * as path from \"path\"\nimport { z } from \"zod\"\nimport {\n\tcheckPermission,\n\ttype Permission,\n\tPermissionDeniedError,\n} from \"@/agents/lib/permissions\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\nimport { trimDiff } from \"@/tools/lib/trim-diff\"\n\n/**\n * Check if a path is contained within a directory\n */\nfunction isPathWithin(directory: string, filepath: string): boolean {\n\tconst relative = path.relative(directory, filepath)\n\treturn !relative.startsWith(\"..\") && !path.isAbsolute(relative)\n}\n\nconst description = `Writes a file to the local filesystem.\n\nUsage:\n- This tool will overwrite the existing file if there is one at the provided path.\n- If this is an existing file, you MUST use the Read tool first to read the file's contents. This tool will fail if you did not read the file first.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.\n- Only use emojis if the user explicitly requests it. Avoid writing emojis to files unless asked.\n- Writing to paths outside the current working directory will include a warning.`\n\nconst inputSchema = z.object({\n\tfilePath: z\n\t\t.string()\n\t\t.describe(\n\t\t\t\"The absolute path to the file to write (must be absolute, not relative)\",\n\t\t),\n\tcontent: z.string().describe(\"The content to write to the file\"),\n})\n\nconst outputSchema = toolOutput({\n\tpending: {\n\t\tfilePath: z.string(),\n\t\tresult: z.undefined(),\n\t},\n\tsuccess: {\n\t\tfilePath: z.string(),\n\t\tresult: z.string(),\n\t\tcontent: z.string(),\n\t\tlineCount: z.number(),\n\t\tbyteSize: z.number(),\n\t\twasOverwrite: z.boolean(),\n\t\tdiff: z.string().optional(),\n\t\twarning: z.string().optional(),\n\t},\n\terror: {\n\t\tfilePath: z.string(),\n\t},\n})\n\n/**\n * Create a write tool with custom permission patterns.\n *\n * @param permissions - File path pattern to permission mapping, or a single permission for all files.\n *                     Patterns support wildcards (*) for matching.\n *                     Default requires approval for all writes.\n *\n * @example\n * // Allow writing all .ts files without approval\n * const tsWrite = createWriteTool({ \"*.ts\": \"allow\", \"*\": \"ask\" })\n *\n * @example\n * // Require approval for everything (default)\n * const strictWrite = createWriteTool({ \"*\": \"ask\" })\n *\n * @example\n * // Allow all writes without approval\n * const permissiveWrite = createWriteTool(\"allow\")\n */\nexport function createWriteTool(\n\tpermissions: Permission | Record<string, Permission> = \"ask\",\n) {\n\tconst permissionPatterns =\n\t\ttypeof permissions === \"string\" ? { \"*\": permissions } : permissions\n\n\treturn tool({\n\t\tdescription,\n\t\tinputSchema,\n\t\toutputSchema,\n\t\tneedsApproval: ({ filePath }) => {\n\t\t\tconst filepath = path.isAbsolute(filePath)\n\t\t\t\t? filePath\n\t\t\t\t: path.join(process.cwd(), filePath)\n\n\t\t\tconst permission = checkPermission(filepath, permissionPatterns)\n\n\t\t\tif (permission === \"deny\") {\n\t\t\t\tthrow new PermissionDeniedError(\"write\", filepath)\n\t\t\t}\n\n\t\t\t// Return true if approval needed (ask), false if auto-allowed\n\t\t\treturn permission === \"ask\"\n\t\t},\n\t\ttoModelOutput: (output) => {\n\t\t\tif (output.status === \"error\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"error-text\",\n\t\t\t\t\tvalue: `Error writing ${output.filePath}: ${output.error}`,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output.status === \"success\") {\n\t\t\t\tlet result = output.result\n\n\t\t\t\t// Add warning if present\n\t\t\t\tif (output.warning) {\n\t\t\t\t\tresult = `⚠️ ${output.warning}\\n\\n${result}`\n\t\t\t\t}\n\n\t\t\t\t// Add diff if overwriting\n\t\t\t\tif (output.diff && output.wasOverwrite) {\n\t\t\t\t\tresult += `\\n\\nChanges:\\n${output.diff}`\n\t\t\t\t}\n\n\t\t\t\treturn { type: \"text\", value: result }\n\t\t\t}\n\t\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t\t},\n\t\tasync *execute({ filePath, content }) {\n\t\t\tconst filepath = path.isAbsolute(filePath)\n\t\t\t\t? filePath\n\t\t\t\t: path.join(process.cwd(), filePath)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"pending\",\n\t\t\t\tmessage: `Writing file: ${filepath}`,\n\t\t\t\tfilePath: filepath,\n\t\t\t\tresult: undefined,\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Check if writing outside working directory\n\t\t\t\tconst cwd = process.cwd()\n\t\t\t\tlet warning: string | undefined\n\t\t\t\tif (!isPathWithin(cwd, filepath)) {\n\t\t\t\t\twarning = `Writing file outside working directory: ${filepath}`\n\t\t\t\t}\n\n\t\t\t\t// Create directory if it doesn't exist\n\t\t\t\tconst dir = path.dirname(filepath)\n\t\t\t\tawait fs.mkdir(dir, { recursive: true })\n\n\t\t\t\t// Check if file exists and get its content for diff\n\t\t\t\tlet exists = false\n\t\t\t\tlet previousContent = \"\"\n\t\t\t\ttry {\n\t\t\t\t\tawait fs.access(filepath)\n\t\t\t\t\texists = true\n\t\t\t\t\tpreviousContent = await fs.readFile(filepath, \"utf-8\")\n\t\t\t\t} catch {\n\t\t\t\t\t// File doesn't exist\n\t\t\t\t}\n\n\t\t\t\t// Write the file\n\t\t\t\tawait fs.writeFile(filepath, content, \"utf-8\")\n\n\t\t\t\t// Calculate stats\n\t\t\t\tconst lineCount = content.split(\"\\n\").length\n\t\t\t\tconst byteSize = Buffer.byteLength(content, \"utf-8\")\n\n\t\t\t\t// Generate diff if overwriting\n\t\t\t\tlet diff: string | undefined\n\t\t\t\tif (exists && previousContent !== content) {\n\t\t\t\t\tdiff = trimDiff(\n\t\t\t\t\t\tcreateTwoFilesPatch(filepath, filepath, previousContent, content),\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst action = exists ? \"overwritten\" : \"created\"\n\t\t\t\tconst message = `File ${action}: ${filepath} (${lineCount} lines, ${byteSize} bytes)`\n\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\tmessage,\n\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\tresult: message,\n\t\t\t\t\tcontent,\n\t\t\t\t\tlineCount,\n\t\t\t\t\tbyteSize,\n\t\t\t\t\twasOverwrite: exists,\n\t\t\t\t\tdiff,\n\t\t\t\t\twarning,\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: `Failed to write ${filepath}`,\n\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n}\n\n/**\n * Default write tool with standard permissions.\n * All file writes require approval by default.\n */\nexport const writeTool = createWriteTool()\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		},
		{
			"path": "tools/lib/trim-diff.ts",
			"type": "registry:lib",
			"content": "/**\n * Trim common indentation from diff output for cleaner display.\n * Removes the minimum shared indentation from all diff content lines.\n */\nexport function trimDiff(diff: string): string {\n\tconst lines = diff.split(\"\\n\")\n\tconst contentLines = lines.filter(\n\t\t(line) =>\n\t\t\t(line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) &&\n\t\t\t!line.startsWith(\"---\") &&\n\t\t\t!line.startsWith(\"+++\"),\n\t)\n\n\tif (contentLines.length === 0) return diff\n\n\tlet min = Infinity\n\tfor (const line of contentLines) {\n\t\tconst content = line.slice(1)\n\t\tif (content.trim().length > 0) {\n\t\t\tconst match = content.match(/^(\\s*)/)\n\t\t\tif (match) min = Math.min(min, match[1]!.length)\n\t\t}\n\t}\n\n\tif (min === Infinity || min === 0) return diff\n\n\tconst trimmedLines = lines.map((line) => {\n\t\tif (\n\t\t\t(line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) &&\n\t\t\t!line.startsWith(\"---\") &&\n\t\t\t!line.startsWith(\"+++\")\n\t\t) {\n\t\t\tconst prefix = line[0]\n\t\t\tconst content = line.slice(1)\n\t\t\treturn prefix + content.slice(min)\n\t\t}\n\t\treturn line\n\t})\n\n\treturn trimmedLines.join(\"\\n\")\n}\n"
		},
		{
			"path": "agents/lib/permissions.ts",
			"type": "registry:lib",
			"content": "/**\n * Permission level for a tool operation.\n * - \"allow\": Auto-approve, no user confirmation needed\n * - \"deny\": Block the operation entirely\n * - \"ask\": Require user approval before proceeding\n */\nexport type Permission = \"allow\" | \"deny\" | \"ask\"\n\nexport const FILE_READ_COMMANDS: Record<string, Permission> = {\n\t\"ls*\": \"allow\",\n\t\"pwd*\": \"allow\",\n\t\"cat*\": \"allow\",\n\t\"head*\": \"allow\",\n\t\"tail*\": \"allow\",\n\t\"less*\": \"allow\",\n\t\"more*\": \"allow\",\n\t\"wc*\": \"allow\",\n\t\"file*\": \"allow\",\n\t\"stat*\": \"allow\",\n\t\"du*\": \"allow\",\n}\n\nexport const SEARCH_COMMANDS: Record<string, Permission> = {\n\t\"grep*\": \"allow\",\n\t\"rg*\": \"allow\",\n\t\"find*\": \"allow\",\n\t\"tree*\": \"allow\",\n\t\"which*\": \"allow\",\n\t\"whereis*\": \"allow\",\n}\n\nexport const TEXT_PROCESSING_COMMANDS: Record<string, Permission> = {\n\t\"sort*\": \"allow\",\n\t\"uniq*\": \"allow\",\n\t\"cut*\": \"allow\",\n\t\"diff*\": \"allow\",\n}\n\nexport const GIT_READ_COMMANDS: Record<string, Permission> = {\n\t\"git status*\": \"allow\",\n\t\"git diff*\": \"allow\",\n\t\"git log*\": \"allow\",\n\t\"git show*\": \"allow\",\n\t\"git branch\": \"allow\",\n\t\"git branch -v\": \"allow\",\n\t\"git branch -a\": \"allow\",\n\t\"git remote -v\": \"allow\",\n\t\"git blame*\": \"allow\",\n}\n\n/** Dangerous commands that should always be denied */\nexport const DANGEROUS_COMMANDS: Record<string, Permission> = {\n\t\"rm -rf /*\": \"deny\",\n\t\"rm -rf /\": \"deny\",\n\t\"sudo rm*\": \"deny\",\n\t\"chmod 777*\": \"deny\",\n}\n\n/**\n * Match a value against a wildcard pattern.\n *\n * @param value - The string to test\n * @param pattern - The pattern with optional wildcards (*)\n *\n * @example\n * matchWildcard(\"ls -la\", \"ls*\") // true\n * matchWildcard(\"git diff HEAD\", \"git diff*\") // true\n * matchWildcard(\"rm -rf /\", \"*\") // true\n */\nexport function matchWildcard(value: string, pattern: string): boolean {\n\tif (pattern === \"*\") return true\n\n\t// Escape regex special chars except *\n\tconst escaped = pattern.replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\")\n\t// Convert * to .* for regex matching\n\tconst regex = new RegExp(`^${escaped.replace(/\\*/g, \".*\")}$`)\n\treturn regex.test(value)\n}\n\n/**\n * Check permission for a value against a set of patterns.\n *\n * Patterns are checked from most specific to least specific:\n * 1. Exact matches (no wildcards) first\n * 2. Longer patterns before shorter ones\n * 3. Wildcard-only pattern (*) last\n *\n * @param value - The value to check (command, file path, etc.)\n * @param patterns - Pattern-to-permission mapping\n * @returns The permission level for this value\n *\n * @example\n * checkPermission(\"ls -la\", { \"ls*\": \"allow\", \"*\": \"ask\" }) // \"allow\"\n * checkPermission(\"npm install\", { \"ls*\": \"allow\", \"*\": \"ask\" }) // \"ask\"\n */\nexport function checkPermission(\n\tvalue: string,\n\tpatterns: Record<string, Permission>,\n): Permission {\n\t// Sort patterns from most specific to least specific\n\tconst sortedPatterns = Object.keys(patterns).sort((a, b) => {\n\t\t// Exact matches (no wildcards) come first\n\t\tconst aHasWildcard = a.includes(\"*\")\n\t\tconst bHasWildcard = b.includes(\"*\")\n\t\tif (!aHasWildcard && bHasWildcard) return -1\n\t\tif (aHasWildcard && !bHasWildcard) return 1\n\n\t\t// Wildcard-only pattern comes last\n\t\tif (a === \"*\") return 1\n\t\tif (b === \"*\") return -1\n\n\t\t// Longer patterns are more specific\n\t\treturn b.length - a.length\n\t})\n\n\tfor (const pattern of sortedPatterns) {\n\t\tif (matchWildcard(value, pattern)) {\n\t\t\treturn patterns[pattern]!\n\t\t}\n\t}\n\n\t// Default to ask if no pattern matches\n\treturn \"ask\"\n}\n\nexport class PermissionDeniedError extends Error {\n\tconstructor(\n\t\tpublic readonly operation: string,\n\t\tpublic readonly value: string,\n\t) {\n\t\tsuper(`Permission denied: ${operation} \"${value}\" is not allowed`)\n\t\tthis.name = \"PermissionDeniedError\"\n\t}\n}\n"
		}
	]
}
