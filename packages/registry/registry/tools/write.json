{
	"name": "write",
	"type": "registry:tool",
	"title": "Write",
	"description": "Writes a file to the local filesystem.",
	"dependencies": [
		"ai",
		"diff",
		"zod"
	],
	"registryDependencies": [
		"agents:lib/permissions"
	],
	"files": [
		{
			"path": "tools/write.ts",
			"type": "registry:tool",
			"content": "import { tool } from \"ai\"\nimport { createTwoFilesPatch } from \"diff\"\nimport { promises as fs } from \"fs\"\nimport * as path from \"path\"\nimport { z } from \"zod\"\nimport { toolOutput } from \"@/tools/lib/tool-output\"\nimport { trimDiff } from \"@/tools/lib/trim-diff\"\nimport {\n\ttype Permission,\n\tcheckPermission,\n\tPermissionDeniedError,\n} from \"@/agents/lib/permissions\"\n\n/**\n * Check if a path is contained within a directory\n */\nfunction isPathWithin(directory: string, filepath: string): boolean {\n\tconst relative = path.relative(directory, filepath)\n\treturn !relative.startsWith(\"..\") && !path.isAbsolute(relative)\n}\n\nconst description = `Writes a file to the local filesystem.\n\nUsage:\n- This tool will overwrite the existing file if there is one at the provided path.\n- If this is an existing file, you MUST use the Read tool first to read the file's contents. This tool will fail if you did not read the file first.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.\n- Only use emojis if the user explicitly requests it. Avoid writing emojis to files unless asked.\n- Writing to paths outside the current working directory will include a warning.`\n\nconst inputSchema = z.object({\n\tfilePath: z\n\t\t.string()\n\t\t.describe(\n\t\t\t\"The absolute path to the file to write (must be absolute, not relative)\",\n\t\t),\n\tcontent: z.string().describe(\"The content to write to the file\"),\n})\n\nconst outputSchema = toolOutput({\n\tpending: {\n\t\tfilePath: z.string(),\n\t\tresult: z.undefined(),\n\t},\n\tsuccess: {\n\t\tfilePath: z.string(),\n\t\tresult: z.string(),\n\t\tcontent: z.string(),\n\t\tlineCount: z.number(),\n\t\tbyteSize: z.number(),\n\t\twasOverwrite: z.boolean(),\n\t\tdiff: z.string().optional(),\n\t\twarning: z.string().optional(),\n\t},\n\terror: {\n\t\tfilePath: z.string(),\n\t},\n})\n\n/**\n * Create a write tool with custom permission patterns.\n *\n * @param permissions - File path pattern to permission mapping, or a single permission for all files.\n *                     Patterns support wildcards (*) for matching.\n *                     Default requires approval for all writes.\n *\n * @example\n * // Allow writing all .ts files without approval\n * const tsWrite = createWriteTool({ \"*.ts\": \"allow\", \"*\": \"ask\" })\n *\n * @example\n * // Require approval for everything (default)\n * const strictWrite = createWriteTool({ \"*\": \"ask\" })\n *\n * @example\n * // Allow all writes without approval\n * const permissiveWrite = createWriteTool(\"allow\")\n */\nexport function createWriteTool(\n\tpermissions: Permission | Record<string, Permission> = \"ask\",\n) {\n\tconst permissionPatterns =\n\t\ttypeof permissions === \"string\" ? { \"*\": permissions } : permissions\n\n\treturn tool({\n\t\tdescription,\n\t\tinputSchema,\n\t\toutputSchema,\n\t\tneedsApproval: ({ filePath }) => {\n\t\t\tconst filepath = path.isAbsolute(filePath)\n\t\t\t\t? filePath\n\t\t\t\t: path.join(process.cwd(), filePath)\n\n\t\t\tconst permission = checkPermission(filepath, permissionPatterns)\n\n\t\t\tif (permission === \"deny\") {\n\t\t\t\tthrow new PermissionDeniedError(\"write\", filepath)\n\t\t\t}\n\n\t\t\t// Return true if approval needed (ask), false if auto-allowed\n\t\t\treturn permission === \"ask\"\n\t\t},\n\t\ttoModelOutput: (output) => {\n\t\t\tif (output.status === \"error\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"error-text\",\n\t\t\t\t\tvalue: `Error writing ${output.filePath}: ${output.error}`,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output.status === \"success\") {\n\t\t\t\tlet result = output.result\n\n\t\t\t\t// Add warning if present\n\t\t\t\tif (output.warning) {\n\t\t\t\t\tresult = `⚠️ ${output.warning}\\n\\n${result}`\n\t\t\t\t}\n\n\t\t\t\t// Add diff if overwriting\n\t\t\t\tif (output.diff && output.wasOverwrite) {\n\t\t\t\t\tresult += `\\n\\nChanges:\\n${output.diff}`\n\t\t\t\t}\n\n\t\t\t\treturn { type: \"text\", value: result }\n\t\t\t}\n\t\t\tthrow new Error(\"Invalid output status in toModelOutput\")\n\t\t},\n\t\tasync *execute({ filePath, content }) {\n\t\t\tconst filepath = path.isAbsolute(filePath)\n\t\t\t\t? filePath\n\t\t\t\t: path.join(process.cwd(), filePath)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"pending\",\n\t\t\t\tmessage: `Writing file: ${filepath}`,\n\t\t\t\tfilePath: filepath,\n\t\t\t\tresult: undefined,\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Check if writing outside working directory\n\t\t\t\tconst cwd = process.cwd()\n\t\t\t\tlet warning: string | undefined\n\t\t\t\tif (!isPathWithin(cwd, filepath)) {\n\t\t\t\t\twarning = `Writing file outside working directory: ${filepath}`\n\t\t\t\t}\n\n\t\t\t\t// Create directory if it doesn't exist\n\t\t\t\tconst dir = path.dirname(filepath)\n\t\t\t\tawait fs.mkdir(dir, { recursive: true })\n\n\t\t\t\t// Check if file exists and get its content for diff\n\t\t\t\tlet exists = false\n\t\t\t\tlet previousContent = \"\"\n\t\t\t\ttry {\n\t\t\t\t\tawait fs.access(filepath)\n\t\t\t\t\texists = true\n\t\t\t\t\tpreviousContent = await fs.readFile(filepath, \"utf-8\")\n\t\t\t\t} catch {\n\t\t\t\t\t// File doesn't exist\n\t\t\t\t}\n\n\t\t\t\t// Write the file\n\t\t\t\tawait fs.writeFile(filepath, content, \"utf-8\")\n\n\t\t\t\t// Calculate stats\n\t\t\t\tconst lineCount = content.split(\"\\n\").length\n\t\t\t\tconst byteSize = Buffer.byteLength(content, \"utf-8\")\n\n\t\t\t\t// Generate diff if overwriting\n\t\t\t\tlet diff: string | undefined\n\t\t\t\tif (exists && previousContent !== content) {\n\t\t\t\t\tdiff = trimDiff(\n\t\t\t\t\t\tcreateTwoFilesPatch(filepath, filepath, previousContent, content),\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst action = exists ? \"overwritten\" : \"created\"\n\t\t\t\tconst message = `File ${action}: ${filepath} (${lineCount} lines, ${byteSize} bytes)`\n\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"success\",\n\t\t\t\t\tmessage,\n\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\tresult: message,\n\t\t\t\t\tcontent,\n\t\t\t\t\tlineCount,\n\t\t\t\t\tbyteSize,\n\t\t\t\t\twasOverwrite: exists,\n\t\t\t\t\tdiff,\n\t\t\t\t\twarning,\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: `Failed to write ${filepath}`,\n\t\t\t\t\tfilePath: filepath,\n\t\t\t\t\terror: error instanceof Error ? error.message : String(error),\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n}\n\n/**\n * Default write tool with standard permissions.\n * All file writes require approval by default.\n */\nexport const writeTool = createWriteTool()\n"
		},
		{
			"path": "tools/lib/tool-output.ts",
			"type": "registry:lib",
			"content": "import { z } from \"zod\"\n\n/**\n * Creates a union schema for tool output with pending, success, error, and optional streaming states.\n * This ensures consistent output structure across all tools.\n */\nexport function toolOutput<\n\tP extends Record<string, z.ZodTypeAny>,\n\tS extends Record<string, z.ZodTypeAny>,\n\tE extends Record<string, z.ZodTypeAny>,\n\tT extends Record<string, z.ZodTypeAny> | undefined = undefined,\n>({\n\tpending,\n\tsuccess,\n\terror,\n\tstreaming,\n}: {\n\tpending: P\n\tsuccess: S\n\terror: E\n\tstreaming?: T\n}) {\n\treturn z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t\t...pending,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\t...success,\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t\t...error,\n\t\t}),\n\t\t...(streaming\n\t\t\t? [\n\t\t\t\t\tz.object({\n\t\t\t\t\t\tstatus: z.literal(\"streaming\"),\n\t\t\t\t\t\tmessage: z.string(),\n\t\t\t\t\t\t...streaming,\n\t\t\t\t\t}),\n\t\t\t\t]\n\t\t\t: []),\n\t])\n}\n"
		},
		{
			"path": "tools/lib/trim-diff.ts",
			"type": "registry:lib",
			"content": "/**\n * Trim common indentation from diff output for cleaner display.\n * Removes the minimum shared indentation from all diff content lines.\n */\nexport function trimDiff(diff: string): string {\n\tconst lines = diff.split(\"\\n\")\n\tconst contentLines = lines.filter(\n\t\t(line) =>\n\t\t\t(line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) &&\n\t\t\t!line.startsWith(\"---\") &&\n\t\t\t!line.startsWith(\"+++\"),\n\t)\n\n\tif (contentLines.length === 0) return diff\n\n\tlet min = Infinity\n\tfor (const line of contentLines) {\n\t\tconst content = line.slice(1)\n\t\tif (content.trim().length > 0) {\n\t\t\tconst match = content.match(/^(\\s*)/)\n\t\t\tif (match) min = Math.min(min, match[1]!.length)\n\t\t}\n\t}\n\n\tif (min === Infinity || min === 0) return diff\n\n\tconst trimmedLines = lines.map((line) => {\n\t\tif (\n\t\t\t(line.startsWith(\"+\") || line.startsWith(\"-\") || line.startsWith(\" \")) &&\n\t\t\t!line.startsWith(\"---\") &&\n\t\t\t!line.startsWith(\"+++\")\n\t\t) {\n\t\t\tconst prefix = line[0]\n\t\t\tconst content = line.slice(1)\n\t\t\treturn prefix + content.slice(min)\n\t\t}\n\t\treturn line\n\t})\n\n\treturn trimmedLines.join(\"\\n\")\n}\n"
		}
	]
}
